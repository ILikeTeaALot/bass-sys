/* automatically generated by rust-bindgen 0.69.4 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use std::ops::{Deref, Not};

#[derive(Clone, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum BOOL {
	FALSE = 0,
	TRUE = 1,
}

impl Default for BOOL {
	fn default() -> Self {
		Self::FALSE
	}
}

impl Not for BOOL {
	type Output = bool;

	fn not(self) -> Self::Output {
		!match self {
			BOOL::FALSE => false,
			_ => true,
		}
	}
}

impl AsRef<bool> for BOOL {
	fn as_ref(&self) -> &bool {
		&self
	}
}

// impl Into<bool> for BOOL {
// 	fn into(self) -> bool {
// 		match self {
// 			BOOL::FALSE => false,
// 			_ => true,
// 		}
// 	}
// }

impl From<BOOL> for bool {
	fn from(value: BOOL) -> Self {
		match value {
			BOOL::FALSE => false,
			_ => true,
		}
	}
}

impl Deref for BOOL {
	type Target = bool;

	fn deref(&self) -> &Self::Target {
		match self {
			BOOL::FALSE => &false,
			_ => &true,
		}
	}
}

impl From<BOOL> for DWORD {
	fn from(value: BOOL) -> DWORD {
		// DWORD(value as u32)
		value as u32
	}
}

// impl From<BOOL> for u32 {
// 	fn from(value: BOOL) -> Self {
// 		value as u32
// 	}
// }

pub const TRUE: BOOL = BOOL::TRUE;
pub const FALSE: BOOL = BOOL::FALSE;

pub const BASSVERSION: u32 = 516;
#[allow(unsafe_code)]
pub const BASSVERSIONTEXT: &::std::ffi::CStr =
    unsafe { ::std::ffi::CStr::from_bytes_with_nul_unchecked(b"2.4\0") };
pub const BASS_OK: u32 = 0;
pub const BASS_ERROR_MEM: u32 = 1;
pub const BASS_ERROR_FILEOPEN: u32 = 2;
pub const BASS_ERROR_DRIVER: u32 = 3;
pub const BASS_ERROR_BUFLOST: u32 = 4;
pub const BASS_ERROR_HANDLE: u32 = 5;
pub const BASS_ERROR_FORMAT: u32 = 6;
pub const BASS_ERROR_POSITION: u32 = 7;
pub const BASS_ERROR_INIT: u32 = 8;
pub const BASS_ERROR_START: u32 = 9;
pub const BASS_ERROR_SSL: u32 = 10;
pub const BASS_ERROR_REINIT: u32 = 11;
pub const BASS_ERROR_ALREADY: u32 = 14;
pub const BASS_ERROR_NOTAUDIO: u32 = 17;
pub const BASS_ERROR_NOCHAN: u32 = 18;
pub const BASS_ERROR_ILLTYPE: u32 = 19;
pub const BASS_ERROR_ILLPARAM: u32 = 20;
pub const BASS_ERROR_NO3D: u32 = 21;
pub const BASS_ERROR_NOEAX: u32 = 22;
pub const BASS_ERROR_DEVICE: u32 = 23;
pub const BASS_ERROR_NOPLAY: u32 = 24;
pub const BASS_ERROR_FREQ: u32 = 25;
pub const BASS_ERROR_NOTFILE: u32 = 27;
pub const BASS_ERROR_NOHW: u32 = 29;
pub const BASS_ERROR_EMPTY: u32 = 31;
pub const BASS_ERROR_NONET: u32 = 32;
pub const BASS_ERROR_CREATE: u32 = 33;
pub const BASS_ERROR_NOFX: u32 = 34;
pub const BASS_ERROR_NOTAVAIL: u32 = 37;
pub const BASS_ERROR_DECODE: u32 = 38;
pub const BASS_ERROR_DX: u32 = 39;
pub const BASS_ERROR_TIMEOUT: u32 = 40;
pub const BASS_ERROR_FILEFORM: u32 = 41;
pub const BASS_ERROR_SPEAKER: u32 = 42;
pub const BASS_ERROR_VERSION: u32 = 43;
pub const BASS_ERROR_CODEC: u32 = 44;
pub const BASS_ERROR_ENDED: u32 = 45;
pub const BASS_ERROR_BUSY: u32 = 46;
pub const BASS_ERROR_UNSTREAMABLE: u32 = 47;
pub const BASS_ERROR_PROTOCOL: u32 = 48;
pub const BASS_ERROR_DENIED: u32 = 49;
pub const BASS_ERROR_UNKNOWN: i32 = -1;
pub const BASS_CONFIG_BUFFER: u32 = 0;
pub const BASS_CONFIG_UPDATEPERIOD: u32 = 1;
pub const BASS_CONFIG_GVOL_SAMPLE: u32 = 4;
pub const BASS_CONFIG_GVOL_STREAM: u32 = 5;
pub const BASS_CONFIG_GVOL_MUSIC: u32 = 6;
pub const BASS_CONFIG_CURVE_VOL: u32 = 7;
pub const BASS_CONFIG_CURVE_PAN: u32 = 8;
pub const BASS_CONFIG_FLOATDSP: u32 = 9;
pub const BASS_CONFIG_3DALGORITHM: u32 = 10;
pub const BASS_CONFIG_NET_TIMEOUT: u32 = 11;
pub const BASS_CONFIG_NET_BUFFER: u32 = 12;
pub const BASS_CONFIG_PAUSE_NOPLAY: u32 = 13;
pub const BASS_CONFIG_NET_PREBUF: u32 = 15;
pub const BASS_CONFIG_NET_PASSIVE: u32 = 18;
pub const BASS_CONFIG_REC_BUFFER: u32 = 19;
pub const BASS_CONFIG_NET_PLAYLIST: u32 = 21;
pub const BASS_CONFIG_MUSIC_VIRTUAL: u32 = 22;
pub const BASS_CONFIG_VERIFY: u32 = 23;
pub const BASS_CONFIG_UPDATETHREADS: u32 = 24;
pub const BASS_CONFIG_DEV_BUFFER: u32 = 27;
pub const BASS_CONFIG_REC_LOOPBACK: u32 = 28;
pub const BASS_CONFIG_VISTA_TRUEPOS: u32 = 30;
pub const BASS_CONFIG_IOS_SESSION: u32 = 34;
pub const BASS_CONFIG_IOS_MIXAUDIO: u32 = 34;
pub const BASS_CONFIG_DEV_DEFAULT: u32 = 36;
pub const BASS_CONFIG_NET_READTIMEOUT: u32 = 37;
pub const BASS_CONFIG_VISTA_SPEAKERS: u32 = 38;
pub const BASS_CONFIG_IOS_SPEAKER: u32 = 39;
pub const BASS_CONFIG_MF_DISABLE: u32 = 40;
pub const BASS_CONFIG_HANDLES: u32 = 41;
pub const BASS_CONFIG_UNICODE: u32 = 42;
pub const BASS_CONFIG_SRC: u32 = 43;
pub const BASS_CONFIG_SRC_SAMPLE: u32 = 44;
pub const BASS_CONFIG_ASYNCFILE_BUFFER: u32 = 45;
pub const BASS_CONFIG_OGG_PRESCAN: u32 = 47;
pub const BASS_CONFIG_MF_VIDEO: u32 = 48;
pub const BASS_CONFIG_AIRPLAY: u32 = 49;
pub const BASS_CONFIG_DEV_NONSTOP: u32 = 50;
pub const BASS_CONFIG_IOS_NOCATEGORY: u32 = 51;
pub const BASS_CONFIG_VERIFY_NET: u32 = 52;
pub const BASS_CONFIG_DEV_PERIOD: u32 = 53;
pub const BASS_CONFIG_FLOAT: u32 = 54;
pub const BASS_CONFIG_NET_SEEK: u32 = 56;
pub const BASS_CONFIG_AM_DISABLE: u32 = 58;
pub const BASS_CONFIG_NET_PLAYLIST_DEPTH: u32 = 59;
pub const BASS_CONFIG_NET_PREBUF_WAIT: u32 = 60;
pub const BASS_CONFIG_ANDROID_SESSIONID: u32 = 62;
pub const BASS_CONFIG_WASAPI_PERSIST: u32 = 65;
pub const BASS_CONFIG_REC_WASAPI: u32 = 66;
pub const BASS_CONFIG_ANDROID_AAUDIO: u32 = 67;
pub const BASS_CONFIG_SAMPLE_ONEHANDLE: u32 = 69;
pub const BASS_CONFIG_NET_META: u32 = 71;
pub const BASS_CONFIG_NET_RESTRATE: u32 = 72;
pub const BASS_CONFIG_REC_DEFAULT: u32 = 73;
pub const BASS_CONFIG_NORAMP: u32 = 74;
pub const BASS_CONFIG_NET_AGENT: u32 = 16;
pub const BASS_CONFIG_NET_PROXY: u32 = 17;
pub const BASS_CONFIG_IOS_NOTIFY: u32 = 46;
pub const BASS_CONFIG_ANDROID_JAVAVM: u32 = 63;
pub const BASS_CONFIG_LIBSSL: u32 = 64;
pub const BASS_CONFIG_FILENAME: u32 = 75;
pub const BASS_CONFIG_THREAD: u32 = 1073741824;
pub const BASS_IOS_SESSION_MIX: u32 = 1;
pub const BASS_IOS_SESSION_DUCK: u32 = 2;
pub const BASS_IOS_SESSION_AMBIENT: u32 = 4;
pub const BASS_IOS_SESSION_SPEAKER: u32 = 8;
pub const BASS_IOS_SESSION_DISABLE: u32 = 16;
pub const BASS_IOS_SESSION_DEACTIVATE: u32 = 32;
pub const BASS_IOS_SESSION_AIRPLAY: u32 = 64;
pub const BASS_IOS_SESSION_BTHFP: u32 = 128;
pub const BASS_IOS_SESSION_BTA2DP: u32 = 256;
pub const BASS_DEVICE_8BITS: u32 = 1;
pub const BASS_DEVICE_MONO: u32 = 2;
pub const BASS_DEVICE_3D: u32 = 4;
pub const BASS_DEVICE_16BITS: u32 = 8;
pub const BASS_DEVICE_REINIT: u32 = 128;
pub const BASS_DEVICE_LATENCY: u32 = 256;
pub const BASS_DEVICE_CPSPEAKERS: u32 = 1024;
pub const BASS_DEVICE_SPEAKERS: u32 = 2048;
pub const BASS_DEVICE_NOSPEAKER: u32 = 4096;
pub const BASS_DEVICE_DMIX: u32 = 8192;
pub const BASS_DEVICE_FREQ: u32 = 16384;
pub const BASS_DEVICE_STEREO: u32 = 32768;
pub const BASS_DEVICE_HOG: u32 = 65536;
pub const BASS_DEVICE_AUDIOTRACK: u32 = 131072;
pub const BASS_DEVICE_DSOUND: u32 = 262144;
pub const BASS_DEVICE_SOFTWARE: u32 = 524288;
pub const BASS_OBJECT_DS: u32 = 1;
pub const BASS_OBJECT_DS3DL: u32 = 2;
pub const BASS_DEVICE_ENABLED: u32 = 1;
pub const BASS_DEVICE_DEFAULT: u32 = 2;
pub const BASS_DEVICE_INIT: u32 = 4;
pub const BASS_DEVICE_LOOPBACK: u32 = 8;
pub const BASS_DEVICE_DEFAULTCOM: u32 = 128;
pub const BASS_DEVICE_TYPE_MASK: u32 = 4278190080;
pub const BASS_DEVICE_TYPE_NETWORK: u32 = 16777216;
pub const BASS_DEVICE_TYPE_SPEAKERS: u32 = 33554432;
pub const BASS_DEVICE_TYPE_LINE: u32 = 50331648;
pub const BASS_DEVICE_TYPE_HEADPHONES: u32 = 67108864;
pub const BASS_DEVICE_TYPE_MICROPHONE: u32 = 83886080;
pub const BASS_DEVICE_TYPE_HEADSET: u32 = 100663296;
pub const BASS_DEVICE_TYPE_HANDSET: u32 = 117440512;
pub const BASS_DEVICE_TYPE_DIGITAL: u32 = 134217728;
pub const BASS_DEVICE_TYPE_SPDIF: u32 = 150994944;
pub const BASS_DEVICE_TYPE_HDMI: u32 = 167772160;
pub const BASS_DEVICE_TYPE_DISPLAYPORT: u32 = 1073741824;
pub const BASS_DEVICES_AIRPLAY: u32 = 16777216;
pub const DSCAPS_EMULDRIVER: u32 = 32;
pub const DSCAPS_CERTIFIED: u32 = 64;
pub const DSCAPS_HARDWARE: u32 = 2147483648;
pub const DSCCAPS_EMULDRIVER: u32 = 32;
pub const DSCCAPS_CERTIFIED: u32 = 64;
pub const WAVE_FORMAT_1M08: u32 = 1;
pub const WAVE_FORMAT_1S08: u32 = 2;
pub const WAVE_FORMAT_1M16: u32 = 4;
pub const WAVE_FORMAT_1S16: u32 = 8;
pub const WAVE_FORMAT_2M08: u32 = 16;
pub const WAVE_FORMAT_2S08: u32 = 32;
pub const WAVE_FORMAT_2M16: u32 = 64;
pub const WAVE_FORMAT_2S16: u32 = 128;
pub const WAVE_FORMAT_4M08: u32 = 256;
pub const WAVE_FORMAT_4S08: u32 = 512;
pub const WAVE_FORMAT_4M16: u32 = 1024;
pub const WAVE_FORMAT_4S16: u32 = 2048;
pub const BASS_SAMPLE_8BITS: u32 = 1;
pub const BASS_SAMPLE_FLOAT: u32 = 256;
pub const BASS_SAMPLE_MONO: u32 = 2;
pub const BASS_SAMPLE_LOOP: u32 = 4;
pub const BASS_SAMPLE_3D: u32 = 8;
pub const BASS_SAMPLE_SOFTWARE: u32 = 16;
pub const BASS_SAMPLE_MUTEMAX: u32 = 32;
pub const BASS_SAMPLE_VAM: u32 = 64;
pub const BASS_SAMPLE_FX: u32 = 128;
pub const BASS_SAMPLE_OVER_VOL: u32 = 65536;
pub const BASS_SAMPLE_OVER_POS: u32 = 131072;
pub const BASS_SAMPLE_OVER_DIST: u32 = 196608;
pub const BASS_STREAM_PRESCAN: u32 = 131072;
pub const BASS_STREAM_AUTOFREE: u32 = 262144;
pub const BASS_STREAM_RESTRATE: u32 = 524288;
pub const BASS_STREAM_BLOCK: u32 = 1048576;
pub const BASS_STREAM_DECODE: u32 = 2097152;
pub const BASS_STREAM_STATUS: u32 = 8388608;
pub const BASS_MP3_IGNOREDELAY: u32 = 512;
pub const BASS_MP3_SETPOS: u32 = 131072;
pub const BASS_MUSIC_FLOAT: u32 = 256;
pub const BASS_MUSIC_MONO: u32 = 2;
pub const BASS_MUSIC_LOOP: u32 = 4;
pub const BASS_MUSIC_3D: u32 = 8;
pub const BASS_MUSIC_FX: u32 = 128;
pub const BASS_MUSIC_AUTOFREE: u32 = 262144;
pub const BASS_MUSIC_DECODE: u32 = 2097152;
pub const BASS_MUSIC_PRESCAN: u32 = 131072;
pub const BASS_MUSIC_CALCLEN: u32 = 131072;
pub const BASS_MUSIC_RAMP: u32 = 512;
pub const BASS_MUSIC_RAMPS: u32 = 1024;
pub const BASS_MUSIC_SURROUND: u32 = 2048;
pub const BASS_MUSIC_SURROUND2: u32 = 4096;
pub const BASS_MUSIC_FT2PAN: u32 = 8192;
pub const BASS_MUSIC_FT2MOD: u32 = 8192;
pub const BASS_MUSIC_PT1MOD: u32 = 16384;
pub const BASS_MUSIC_NONINTER: u32 = 65536;
pub const BASS_MUSIC_SINCINTER: u32 = 8388608;
pub const BASS_MUSIC_POSRESET: u32 = 32768;
pub const BASS_MUSIC_POSRESETEX: u32 = 4194304;
pub const BASS_MUSIC_STOPBACK: u32 = 524288;
pub const BASS_MUSIC_NOSAMPLE: u32 = 1048576;
pub const BASS_SPEAKER_FRONT: u32 = 16777216;
pub const BASS_SPEAKER_REAR: u32 = 33554432;
pub const BASS_SPEAKER_CENLFE: u32 = 50331648;
pub const BASS_SPEAKER_SIDE: u32 = 67108864;
pub const BASS_SPEAKER_LEFT: u32 = 268435456;
pub const BASS_SPEAKER_RIGHT: u32 = 536870912;
pub const BASS_SPEAKER_FRONTLEFT: u32 = 285212672;
pub const BASS_SPEAKER_FRONTRIGHT: u32 = 553648128;
pub const BASS_SPEAKER_REARLEFT: u32 = 301989888;
pub const BASS_SPEAKER_REARRIGHT: u32 = 570425344;
pub const BASS_SPEAKER_CENTER: u32 = 318767104;
pub const BASS_SPEAKER_LFE: u32 = 587202560;
pub const BASS_SPEAKER_SIDELEFT: u32 = 335544320;
pub const BASS_SPEAKER_SIDERIGHT: u32 = 603979776;
pub const BASS_SPEAKER_REAR2: u32 = 67108864;
pub const BASS_SPEAKER_REAR2LEFT: u32 = 335544320;
pub const BASS_SPEAKER_REAR2RIGHT: u32 = 603979776;
pub const BASS_ASYNCFILE: u32 = 1073741824;
pub const BASS_UNICODE: u32 = 2147483648;
pub const BASS_RECORD_ECHOCANCEL: u32 = 8192;
pub const BASS_RECORD_AGC: u32 = 16384;
pub const BASS_RECORD_PAUSE: u32 = 32768;
pub const BASS_VAM_HARDWARE: u32 = 1;
pub const BASS_VAM_SOFTWARE: u32 = 2;
pub const BASS_VAM_TERM_TIME: u32 = 4;
pub const BASS_VAM_TERM_DIST: u32 = 8;
pub const BASS_VAM_TERM_PRIO: u32 = 16;
pub const BASS_ORIGRES_FLOAT: u32 = 65536;
pub const BASS_CTYPE_SAMPLE: u32 = 1;
pub const BASS_CTYPE_RECORD: u32 = 2;
pub const BASS_CTYPE_STREAM: u32 = 65536;
pub const BASS_CTYPE_STREAM_VORBIS: u32 = 65538;
pub const BASS_CTYPE_STREAM_OGG: u32 = 65538;
pub const BASS_CTYPE_STREAM_MP1: u32 = 65539;
pub const BASS_CTYPE_STREAM_MP2: u32 = 65540;
pub const BASS_CTYPE_STREAM_MP3: u32 = 65541;
pub const BASS_CTYPE_STREAM_AIFF: u32 = 65542;
pub const BASS_CTYPE_STREAM_CA: u32 = 65543;
pub const BASS_CTYPE_STREAM_MF: u32 = 65544;
pub const BASS_CTYPE_STREAM_AM: u32 = 65545;
pub const BASS_CTYPE_STREAM_SAMPLE: u32 = 65546;
pub const BASS_CTYPE_STREAM_DUMMY: u32 = 98304;
pub const BASS_CTYPE_STREAM_DEVICE: u32 = 98305;
pub const BASS_CTYPE_STREAM_WAV: u32 = 262144;
pub const BASS_CTYPE_STREAM_WAV_PCM: u32 = 327681;
pub const BASS_CTYPE_STREAM_WAV_FLOAT: u32 = 327683;
pub const BASS_CTYPE_MUSIC_MOD: u32 = 131072;
pub const BASS_CTYPE_MUSIC_MTM: u32 = 131073;
pub const BASS_CTYPE_MUSIC_S3M: u32 = 131074;
pub const BASS_CTYPE_MUSIC_XM: u32 = 131075;
pub const BASS_CTYPE_MUSIC_IT: u32 = 131076;
pub const BASS_CTYPE_MUSIC_MO3: u32 = 256;
pub const BASS_PLUGIN_PROC: u32 = 1;
pub const BASS_3DMODE_NORMAL: u32 = 0;
pub const BASS_3DMODE_RELATIVE: u32 = 1;
pub const BASS_3DMODE_OFF: u32 = 2;
pub const BASS_3DALG_DEFAULT: u32 = 0;
pub const BASS_3DALG_OFF: u32 = 1;
pub const BASS_3DALG_FULL: u32 = 2;
pub const BASS_3DALG_LIGHT: u32 = 3;
pub const BASS_SAMCHAN_NEW: u32 = 1;
pub const BASS_SAMCHAN_STREAM: u32 = 2;
pub const BASS_STREAMPROC_END: u32 = 2147483648;
pub const STREAMFILE_NOBUFFER: u32 = 0;
pub const STREAMFILE_BUFFER: u32 = 1;
pub const STREAMFILE_BUFFERPUSH: u32 = 2;
pub const BASS_FILEDATA_END: u32 = 0;
pub const BASS_FILEPOS_CURRENT: u32 = 0;
pub const BASS_FILEPOS_DECODE: u32 = 0;
pub const BASS_FILEPOS_DOWNLOAD: u32 = 1;
pub const BASS_FILEPOS_END: u32 = 2;
pub const BASS_FILEPOS_START: u32 = 3;
pub const BASS_FILEPOS_CONNECTED: u32 = 4;
pub const BASS_FILEPOS_BUFFER: u32 = 5;
pub const BASS_FILEPOS_SOCKET: u32 = 6;
pub const BASS_FILEPOS_ASYNCBUF: u32 = 7;
pub const BASS_FILEPOS_SIZE: u32 = 8;
pub const BASS_FILEPOS_BUFFERING: u32 = 9;
pub const BASS_FILEPOS_AVAILABLE: u32 = 10;
pub const BASS_SYNC_POS: u32 = 0;
pub const BASS_SYNC_END: u32 = 2;
pub const BASS_SYNC_META: u32 = 4;
pub const BASS_SYNC_SLIDE: u32 = 5;
pub const BASS_SYNC_STALL: u32 = 6;
pub const BASS_SYNC_DOWNLOAD: u32 = 7;
pub const BASS_SYNC_FREE: u32 = 8;
pub const BASS_SYNC_SETPOS: u32 = 11;
pub const BASS_SYNC_MUSICPOS: u32 = 10;
pub const BASS_SYNC_MUSICINST: u32 = 1;
pub const BASS_SYNC_MUSICFX: u32 = 3;
pub const BASS_SYNC_OGG_CHANGE: u32 = 12;
pub const BASS_SYNC_DEV_FAIL: u32 = 14;
pub const BASS_SYNC_DEV_FORMAT: u32 = 15;
pub const BASS_SYNC_THREAD: u32 = 536870912;
pub const BASS_SYNC_MIXTIME: u32 = 1073741824;
pub const BASS_SYNC_ONETIME: u32 = 2147483648;
pub const BASS_ACTIVE_STOPPED: u32 = 0;
pub const BASS_ACTIVE_PLAYING: u32 = 1;
pub const BASS_ACTIVE_STALLED: u32 = 2;
pub const BASS_ACTIVE_PAUSED: u32 = 3;
pub const BASS_ACTIVE_PAUSED_DEVICE: u32 = 4;
pub const BASS_ATTRIB_FREQ: u32 = 1;
pub const BASS_ATTRIB_VOL: u32 = 2;
pub const BASS_ATTRIB_PAN: u32 = 3;
pub const BASS_ATTRIB_EAXMIX: u32 = 4;
pub const BASS_ATTRIB_NOBUFFER: u32 = 5;
pub const BASS_ATTRIB_VBR: u32 = 6;
pub const BASS_ATTRIB_CPU: u32 = 7;
pub const BASS_ATTRIB_SRC: u32 = 8;
pub const BASS_ATTRIB_NET_RESUME: u32 = 9;
pub const BASS_ATTRIB_SCANINFO: u32 = 10;
pub const BASS_ATTRIB_NORAMP: u32 = 11;
pub const BASS_ATTRIB_BITRATE: u32 = 12;
pub const BASS_ATTRIB_BUFFER: u32 = 13;
pub const BASS_ATTRIB_GRANULE: u32 = 14;
pub const BASS_ATTRIB_USER: u32 = 15;
pub const BASS_ATTRIB_TAIL: u32 = 16;
pub const BASS_ATTRIB_PUSH_LIMIT: u32 = 17;
pub const BASS_ATTRIB_DOWNLOADPROC: u32 = 18;
pub const BASS_ATTRIB_VOLDSP: u32 = 19;
pub const BASS_ATTRIB_VOLDSP_PRIORITY: u32 = 20;
pub const BASS_ATTRIB_MUSIC_AMPLIFY: u32 = 256;
pub const BASS_ATTRIB_MUSIC_PANSEP: u32 = 257;
pub const BASS_ATTRIB_MUSIC_PSCALER: u32 = 258;
pub const BASS_ATTRIB_MUSIC_BPM: u32 = 259;
pub const BASS_ATTRIB_MUSIC_SPEED: u32 = 260;
pub const BASS_ATTRIB_MUSIC_VOL_GLOBAL: u32 = 261;
pub const BASS_ATTRIB_MUSIC_ACTIVE: u32 = 262;
pub const BASS_ATTRIB_MUSIC_VOL_CHAN: u32 = 512;
pub const BASS_ATTRIB_MUSIC_VOL_INST: u32 = 768;
pub const BASS_SLIDE_LOG: u32 = 16777216;
pub const BASS_DATA_AVAILABLE: u32 = 0;
pub const BASS_DATA_NOREMOVE: u32 = 268435456;
pub const BASS_DATA_FIXED: u32 = 536870912;
pub const BASS_DATA_FLOAT: u32 = 1073741824;
pub const BASS_DATA_FFT256: u32 = 2147483648;
pub const BASS_DATA_FFT512: u32 = 2147483649;
pub const BASS_DATA_FFT1024: u32 = 2147483650;
pub const BASS_DATA_FFT2048: u32 = 2147483651;
pub const BASS_DATA_FFT4096: u32 = 2147483652;
pub const BASS_DATA_FFT8192: u32 = 2147483653;
pub const BASS_DATA_FFT16384: u32 = 2147483654;
pub const BASS_DATA_FFT32768: u32 = 2147483655;
pub const BASS_DATA_FFT_INDIVIDUAL: u32 = 16;
pub const BASS_DATA_FFT_NOWINDOW: u32 = 32;
pub const BASS_DATA_FFT_REMOVEDC: u32 = 64;
pub const BASS_DATA_FFT_COMPLEX: u32 = 128;
pub const BASS_DATA_FFT_NYQUIST: u32 = 256;
pub const BASS_LEVEL_MONO: u32 = 1;
pub const BASS_LEVEL_STEREO: u32 = 2;
pub const BASS_LEVEL_RMS: u32 = 4;
pub const BASS_LEVEL_VOLPAN: u32 = 8;
pub const BASS_LEVEL_NOREMOVE: u32 = 16;
pub const BASS_TAG_ID3: u32 = 0;
pub const BASS_TAG_ID3V2: u32 = 1;
pub const BASS_TAG_OGG: u32 = 2;
pub const BASS_TAG_HTTP: u32 = 3;
pub const BASS_TAG_ICY: u32 = 4;
pub const BASS_TAG_META: u32 = 5;
pub const BASS_TAG_APE: u32 = 6;
pub const BASS_TAG_MP4: u32 = 7;
pub const BASS_TAG_WMA: u32 = 8;
pub const BASS_TAG_VENDOR: u32 = 9;
pub const BASS_TAG_LYRICS3: u32 = 10;
pub const BASS_TAG_CA_CODEC: u32 = 11;
pub const BASS_TAG_MF: u32 = 13;
pub const BASS_TAG_WAVEFORMAT: u32 = 14;
pub const BASS_TAG_AM_NAME: u32 = 16;
pub const BASS_TAG_ID3V2_2: u32 = 17;
pub const BASS_TAG_AM_MIME: u32 = 18;
pub const BASS_TAG_LOCATION: u32 = 19;
pub const BASS_TAG_RIFF_INFO: u32 = 256;
pub const BASS_TAG_RIFF_BEXT: u32 = 257;
pub const BASS_TAG_RIFF_CART: u32 = 258;
pub const BASS_TAG_RIFF_DISP: u32 = 259;
pub const BASS_TAG_RIFF_CUE: u32 = 260;
pub const BASS_TAG_RIFF_SMPL: u32 = 261;
pub const BASS_TAG_APE_BINARY: u32 = 4096;
pub const BASS_TAG_MUSIC_NAME: u32 = 65536;
pub const BASS_TAG_MUSIC_MESSAGE: u32 = 65537;
pub const BASS_TAG_MUSIC_ORDERS: u32 = 65538;
pub const BASS_TAG_MUSIC_AUTH: u32 = 65539;
pub const BASS_TAG_MUSIC_INST: u32 = 65792;
pub const BASS_TAG_MUSIC_CHAN: u32 = 66048;
pub const BASS_TAG_MUSIC_SAMPLE: u32 = 66304;
pub const BASS_POS_BYTE: u32 = 0;
pub const BASS_POS_MUSIC_ORDER: u32 = 1;
pub const BASS_POS_OGG: u32 = 3;
pub const BASS_POS_END: u32 = 16;
pub const BASS_POS_LOOP: u32 = 17;
pub const BASS_POS_FLUSH: u32 = 16777216;
pub const BASS_POS_RESET: u32 = 33554432;
pub const BASS_POS_RELATIVE: u32 = 67108864;
pub const BASS_POS_INEXACT: u32 = 134217728;
pub const BASS_POS_DECODE: u32 = 268435456;
pub const BASS_POS_DECODETO: u32 = 536870912;
pub const BASS_POS_SCAN: u32 = 1073741824;
pub const BASS_NODEVICE: u32 = 131072;
pub const BASS_INPUT_OFF: u32 = 65536;
pub const BASS_INPUT_ON: u32 = 131072;
pub const BASS_INPUT_TYPE_MASK: u32 = 4278190080;
pub const BASS_INPUT_TYPE_UNDEF: u32 = 0;
pub const BASS_INPUT_TYPE_DIGITAL: u32 = 16777216;
pub const BASS_INPUT_TYPE_LINE: u32 = 33554432;
pub const BASS_INPUT_TYPE_MIC: u32 = 50331648;
pub const BASS_INPUT_TYPE_SYNTH: u32 = 67108864;
pub const BASS_INPUT_TYPE_CD: u32 = 83886080;
pub const BASS_INPUT_TYPE_PHONE: u32 = 100663296;
pub const BASS_INPUT_TYPE_SPEAKER: u32 = 117440512;
pub const BASS_INPUT_TYPE_WAVE: u32 = 134217728;
pub const BASS_INPUT_TYPE_AUX: u32 = 150994944;
pub const BASS_INPUT_TYPE_ANALOG: u32 = 167772160;
pub const BASS_FX_DX8_CHORUS: u32 = 0;
pub const BASS_FX_DX8_COMPRESSOR: u32 = 1;
pub const BASS_FX_DX8_DISTORTION: u32 = 2;
pub const BASS_FX_DX8_ECHO: u32 = 3;
pub const BASS_FX_DX8_FLANGER: u32 = 4;
pub const BASS_FX_DX8_GARGLE: u32 = 5;
pub const BASS_FX_DX8_I3DL2REVERB: u32 = 6;
pub const BASS_FX_DX8_PARAMEQ: u32 = 7;
pub const BASS_FX_DX8_REVERB: u32 = 8;
pub const BASS_FX_VOLUME: u32 = 9;
pub const BASS_DX8_PHASE_NEG_180: u32 = 0;
pub const BASS_DX8_PHASE_NEG_90: u32 = 1;
pub const BASS_DX8_PHASE_ZERO: u32 = 2;
pub const BASS_DX8_PHASE_90: u32 = 3;
pub const BASS_DX8_PHASE_180: u32 = 4;
pub const BASS_IOSNOTIFY_INTERRUPT: u32 = 1;
pub const BASS_IOSNOTIFY_INTERRUPT_END: u32 = 2;
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct int_least64_t(pub i64);
impl ::std::ops::Deref for int_least64_t {
    type Target = i64;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for int_least64_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uint_least64_t(pub u64);
impl ::std::ops::Deref for uint_least64_t {
    type Target = u64;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for uint_least64_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct int_fast64_t(pub i64);
impl ::std::ops::Deref for int_fast64_t {
    type Target = i64;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for int_fast64_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uint_fast64_t(pub u64);
impl ::std::ops::Deref for uint_fast64_t {
    type Target = u64;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for uint_fast64_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct int_least32_t(pub i32);
impl ::std::ops::Deref for int_least32_t {
    type Target = i32;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for int_least32_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uint_least32_t(pub u32);
impl ::std::ops::Deref for uint_least32_t {
    type Target = u32;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for uint_least32_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct int_fast32_t(pub i32);
impl ::std::ops::Deref for int_fast32_t {
    type Target = i32;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for int_fast32_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uint_fast32_t(pub u32);
impl ::std::ops::Deref for uint_fast32_t {
    type Target = u32;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for uint_fast32_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct int_least16_t(pub i16);
impl ::std::ops::Deref for int_least16_t {
    type Target = i16;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for int_least16_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uint_least16_t(pub u16);
impl ::std::ops::Deref for uint_least16_t {
    type Target = u16;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for uint_least16_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct int_fast16_t(pub i16);
impl ::std::ops::Deref for int_fast16_t {
    type Target = i16;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for int_fast16_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uint_fast16_t(pub u16);
impl ::std::ops::Deref for uint_fast16_t {
    type Target = u16;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for uint_fast16_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct int_least8_t(pub i8);
impl ::std::ops::Deref for int_least8_t {
    type Target = i8;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for int_least8_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uint_least8_t(pub u8);
impl ::std::ops::Deref for uint_least8_t {
    type Target = u8;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for uint_least8_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct int_fast8_t(pub i8);
impl ::std::ops::Deref for int_fast8_t {
    type Target = i8;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for int_fast8_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uint_fast8_t(pub u8);
impl ::std::ops::Deref for uint_fast8_t {
    type Target = u8;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for uint_fast8_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct intmax_t(pub ::std::os::raw::c_long);
impl ::std::ops::Deref for intmax_t {
    type Target = ::std::os::raw::c_long;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for intmax_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uintmax_t(pub ::std::os::raw::c_ulong);
impl ::std::ops::Deref for uintmax_t {
    type Target = ::std::os::raw::c_ulong;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for uintmax_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BYTE(pub u8);
impl ::std::ops::Deref for BYTE {
    type Target = u8;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for BYTE {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
pub type WORD = u16;
pub type DWORD = u32;
pub type QWORD = u64;
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HMUSIC(pub DWORD);
impl ::std::ops::Deref for HMUSIC {
    type Target = DWORD;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for HMUSIC {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HSAMPLE(pub DWORD);
impl ::std::ops::Deref for HSAMPLE {
    type Target = DWORD;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for HSAMPLE {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HCHANNEL(pub DWORD);
impl ::std::ops::Deref for HCHANNEL {
    type Target = DWORD;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for HCHANNEL {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HSTREAM(pub DWORD);
impl ::std::ops::Deref for HSTREAM {
    type Target = DWORD;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for HSTREAM {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HRECORD(pub DWORD);
impl ::std::ops::Deref for HRECORD {
    type Target = DWORD;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for HRECORD {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HSYNC(pub DWORD);
impl ::std::ops::Deref for HSYNC {
    type Target = DWORD;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for HSYNC {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HDSP(pub DWORD);
impl ::std::ops::Deref for HDSP {
    type Target = DWORD;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for HDSP {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HFX(pub DWORD);
impl ::std::ops::Deref for HFX {
    type Target = DWORD;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for HFX {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HPLUGIN(pub DWORD);
impl ::std::ops::Deref for HPLUGIN {
    type Target = DWORD;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for HPLUGIN {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[doc = " Device info structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BASS_DEVICEINFO {
    #[doc = " description"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " driver"]
    pub driver: *const ::std::os::raw::c_char,
    pub flags: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_DEVICEINFO() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DEVICEINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DEVICEINFO>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_DEVICEINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DEVICEINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_DEVICEINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DEVICEINFO),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DEVICEINFO),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DEVICEINFO),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for BASS_DEVICEINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct BASS_INFO {
    #[doc = " device capabilities (DSCAPS_xxx flags)"]
    pub flags: DWORD,
    #[doc = " unused"]
    pub hwsize: DWORD,
    #[doc = " unused"]
    pub hwfree: DWORD,
    #[doc = " unused"]
    pub freesam: DWORD,
    #[doc = " unused"]
    pub free3d: DWORD,
    #[doc = " unused"]
    pub minrate: DWORD,
    #[doc = " unused"]
    pub maxrate: DWORD,
    #[doc = " unused"]
    pub eax: BOOL,
    #[doc = " recommended minimum buffer length in ms"]
    pub minbuf: DWORD,
    #[doc = " DirectSound version"]
    pub dsver: DWORD,
    #[doc = " average delay (in ms) before start of playback"]
    pub latency: DWORD,
    #[doc = " BASS_Init \"flags\" parameter"]
    pub initflags: DWORD,
    #[doc = " number of speakers available"]
    pub speakers: DWORD,
    #[doc = " current output rate"]
    pub freq: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_INFO>(),
        56usize,
        concat!("Size of: ", stringify!(BASS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hwsize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(hwsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hwfree) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(hwfree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freesam) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(freesam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free3d) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(free3d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minrate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(minrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxrate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(maxrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minbuf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(minbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsver) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(dsver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latency) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initflags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(initflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speakers) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(speakers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_INFO),
            "::",
            stringify!(freq)
        )
    );
}
impl Default for BASS_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for BASS_INFO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "BASS_INFO {{ flags: {:?}, hwsize: {:?}, hwfree: {:?}, freesam: {:?}, free3d: {:?}, minrate: {:?}, maxrate: {:?}, minbuf: {:?}, dsver: {:?}, latency: {:?}, initflags: {:?}, speakers: {:?}, freq: {:?} }}" , self . flags , self . hwsize , self . hwfree , self . freesam , self . free3d , self . minrate , self . maxrate , self . minbuf , self . dsver , self . latency , self . initflags , self . speakers , self . freq)
    }
}
#[doc = " Recording device info structure"]
#[repr(C)]
pub struct BASS_RECORDINFO {
    #[doc = " device capabilities (DSCCAPS_xxx flags)"]
    pub flags: DWORD,
    #[doc = " supported standard formats (WAVE_FORMAT_xxx flags)"]
    pub formats: DWORD,
    #[doc = " number of inputs"]
    pub inputs: DWORD,
    #[doc = " TRUE = only 1 input can be set at a time"]
    pub singlein: BOOL,
    #[doc = " current input rate"]
    pub freq: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_RECORDINFO() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_RECORDINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_RECORDINFO>(),
        20usize,
        concat!("Size of: ", stringify!(BASS_RECORDINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_RECORDINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_RECORDINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_RECORDINFO),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formats) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_RECORDINFO),
            "::",
            stringify!(formats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_RECORDINFO),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singlein) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_RECORDINFO),
            "::",
            stringify!(singlein)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_RECORDINFO),
            "::",
            stringify!(freq)
        )
    );
}
impl Default for BASS_RECORDINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for BASS_RECORDINFO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "BASS_RECORDINFO {{ flags: {:?}, formats: {:?}, inputs: {:?}, freq: {:?} }}",
            self.flags, self.formats, self.inputs, self.freq
        )
    }
}
#[doc = " Sample info structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_SAMPLE {
    #[doc = " default playback rate"]
    pub freq: DWORD,
    #[doc = " default volume (0-1)"]
    pub volume: f32,
    #[doc = " default pan (-1=left, 0=middle, 1=right)"]
    pub pan: f32,
    #[doc = " BASS_SAMPLE_xxx flags"]
    pub flags: DWORD,
    #[doc = " length (in bytes)"]
    pub length: DWORD,
    #[doc = " maximum simultaneous playbacks"]
    pub max: DWORD,
    #[doc = " original resolution"]
    pub origres: DWORD,
    #[doc = " number of channels"]
    pub chans: DWORD,
    #[doc = " minimum gap (ms) between creating channels"]
    pub mingap: DWORD,
    #[doc = " BASS_3DMODE_xxx mode"]
    pub mode3d: DWORD,
    #[doc = " minimum distance"]
    pub mindist: f32,
    #[doc = " maximum distance"]
    pub maxdist: f32,
    #[doc = " angle of inside projection cone"]
    pub iangle: DWORD,
    #[doc = " angle of outside projection cone"]
    pub oangle: DWORD,
    #[doc = " delta-volume outside the projection cone"]
    pub outvol: f32,
    #[doc = " unused"]
    pub vam: DWORD,
    #[doc = " unused"]
    pub priority: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_SAMPLE() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_SAMPLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_SAMPLE>(),
        68usize,
        concat!("Size of: ", stringify!(BASS_SAMPLE))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_SAMPLE>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_SAMPLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volume) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pan) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(pan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).origres) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(origres)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chans) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(chans)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mingap) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(mingap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode3d) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(mode3d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mindist) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(mindist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxdist) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(maxdist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iangle) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(iangle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oangle) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(oangle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outvol) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(outvol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vam) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(vam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_SAMPLE),
            "::",
            stringify!(priority)
        )
    );
}
#[doc = " Channel info structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BASS_CHANNELINFO {
    #[doc = " default playback rate"]
    pub freq: DWORD,
    #[doc = " channels"]
    pub chans: DWORD,
    pub flags: DWORD,
    #[doc = " type of channel"]
    pub ctype: DWORD,
    #[doc = " original resolution"]
    pub origres: DWORD,
    pub plugin: HPLUGIN,
    pub sample: HSAMPLE,
    pub filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_BASS_CHANNELINFO() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_CHANNELINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_CHANNELINFO>(),
        40usize,
        concat!("Size of: ", stringify!(BASS_CHANNELINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_CHANNELINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_CHANNELINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CHANNELINFO),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chans) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CHANNELINFO),
            "::",
            stringify!(chans)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CHANNELINFO),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctype) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CHANNELINFO),
            "::",
            stringify!(ctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).origres) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CHANNELINFO),
            "::",
            stringify!(origres)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plugin) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CHANNELINFO),
            "::",
            stringify!(plugin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CHANNELINFO),
            "::",
            stringify!(sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CHANNELINFO),
            "::",
            stringify!(filename)
        )
    );
}
impl Default for BASS_CHANNELINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BASS_PLUGINFORM {
    #[doc = " channel type"]
    pub ctype: DWORD,
    #[doc = " format description"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " file extension filter (*.ext1;*.ext2;etc...)"]
    pub exts: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_BASS_PLUGINFORM() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_PLUGINFORM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_PLUGINFORM>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_PLUGINFORM))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_PLUGINFORM>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_PLUGINFORM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_PLUGINFORM),
            "::",
            stringify!(ctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_PLUGINFORM),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_PLUGINFORM),
            "::",
            stringify!(exts)
        )
    );
}
impl Default for BASS_PLUGINFORM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BASS_PLUGININFO {
    #[doc = " version (same form as BASS_GetVersion)"]
    pub version: DWORD,
    #[doc = " number of formats"]
    pub formatc: DWORD,
    #[doc = " the array of formats"]
    pub formats: *const BASS_PLUGINFORM,
}
#[test]
fn bindgen_test_layout_BASS_PLUGININFO() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_PLUGININFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_PLUGININFO>(),
        16usize,
        concat!("Size of: ", stringify!(BASS_PLUGININFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_PLUGININFO>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_PLUGININFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_PLUGININFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formatc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_PLUGININFO),
            "::",
            stringify!(formatc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formats) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_PLUGININFO),
            "::",
            stringify!(formats)
        )
    );
}
impl Default for BASS_PLUGININFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 3D vector (for 3D positions/velocities/orientations)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_3DVECTOR {
    #[doc = " +=right, -=left"]
    pub x: f32,
    #[doc = " +=up, -=down"]
    pub y: f32,
    #[doc = " +=front, -=behind"]
    pub z: f32,
}
#[test]
fn bindgen_test_layout_BASS_3DVECTOR() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_3DVECTOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_3DVECTOR>(),
        12usize,
        concat!("Size of: ", stringify!(BASS_3DVECTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_3DVECTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_3DVECTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_3DVECTOR),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_3DVECTOR),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_3DVECTOR),
            "::",
            stringify!(z)
        )
    );
}
pub type STREAMPROC = ::std::option::Option<
    unsafe extern "C" fn(
        handle: HSTREAM,
        buffer: *mut ::std::os::raw::c_void,
        length: DWORD,
        user: *mut ::std::os::raw::c_void,
    ) -> DWORD,
>;
#[doc = " User file stream callback functions"]
pub type FILECLOSEPROC =
    ::std::option::Option<unsafe extern "C" fn(user: *mut ::std::os::raw::c_void)>;
pub type FILELENPROC =
    ::std::option::Option<unsafe extern "C" fn(user: *mut ::std::os::raw::c_void) -> QWORD>;
pub type FILEREADPROC = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_void,
        length: DWORD,
        user: *mut ::std::os::raw::c_void,
    ) -> DWORD,
>;
pub type FILESEEKPROC = ::std::option::Option<
    unsafe extern "C" fn(offset: QWORD, user: *mut ::std::os::raw::c_void) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Default, Hash, PartialEq, Eq)]
pub struct BASS_FILEPROCS {
    pub close: FILECLOSEPROC,
    pub length: FILELENPROC,
    pub read: FILEREADPROC,
    pub seek: FILESEEKPROC,
}
#[test]
fn bindgen_test_layout_BASS_FILEPROCS() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_FILEPROCS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_FILEPROCS>(),
        32usize,
        concat!("Size of: ", stringify!(BASS_FILEPROCS))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_FILEPROCS>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_FILEPROCS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FILEPROCS),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FILEPROCS),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FILEPROCS),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FILEPROCS),
            "::",
            stringify!(seek)
        )
    );
}
pub type DOWNLOADPROC = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *const ::std::os::raw::c_void,
        length: DWORD,
        user: *mut ::std::os::raw::c_void,
    ),
>;
pub type SYNCPROC = ::std::option::Option<
    unsafe extern "C" fn(
        handle: HSYNC,
        channel: DWORD,
        data: DWORD,
        user: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Sync callback function.\nhandle : The sync that has occured\nchannel: Channel that the sync occured in\ndata   : Additional data associated with the sync's occurance\nuser   : The 'user' parameter given when calling BASS_ChannelSetSync"]
pub type DSPPROC = ::std::option::Option<
    unsafe extern "C" fn(
        handle: HDSP,
        channel: DWORD,
        buffer: *mut ::std::os::raw::c_void,
        length: DWORD,
        user: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " DSP callback function.\nhandle : The DSP handle\nchannel: Channel that the DSP is being applied to\nbuffer : Buffer to apply the DSP to\nlength : Number of bytes in the buffer\nuser   : The 'user' parameter given when calling BASS_ChannelSetDSP"]
pub type RECORDPROC = ::std::option::Option<
    unsafe extern "C" fn(
        handle: HRECORD,
        buffer: *const ::std::os::raw::c_void,
        length: DWORD,
        user: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct tWAVEFORMATEX {
    pub wFormatTag: WORD,
    pub nChannels: WORD,
    pub nSamplesPerSec: DWORD,
    pub nAvgBytesPerSec: DWORD,
    pub nBlockAlign: WORD,
    pub wBitsPerSample: WORD,
    pub cbSize: WORD,
}
#[test]
fn bindgen_test_layout_tWAVEFORMATEX() {
    const UNINIT: ::std::mem::MaybeUninit<tWAVEFORMATEX> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tWAVEFORMATEX>(),
        18usize,
        concat!("Size of: ", stringify!(tWAVEFORMATEX))
    );
    assert_eq!(
        ::std::mem::align_of::<tWAVEFORMATEX>(),
        1usize,
        concat!("Alignment of ", stringify!(tWAVEFORMATEX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wFormatTag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(wFormatTag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nChannels) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(nChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nSamplesPerSec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(nSamplesPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nAvgBytesPerSec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(nAvgBytesPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBlockAlign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(nBlockAlign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wBitsPerSample) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(wBitsPerSample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(cbSize)
        )
    );
}
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct WAVEFORMATEX(pub tWAVEFORMATEX);
impl ::std::ops::Deref for WAVEFORMATEX {
    type Target = tWAVEFORMATEX;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for WAVEFORMATEX {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PWAVEFORMATEX(pub *mut tWAVEFORMATEX);
impl ::std::ops::Deref for PWAVEFORMATEX {
    type Target = *mut tWAVEFORMATEX;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for PWAVEFORMATEX {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LPWAVEFORMATEX(pub *mut tWAVEFORMATEX);
impl ::std::ops::Deref for LPWAVEFORMATEX {
    type Target = *mut tWAVEFORMATEX;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for LPWAVEFORMATEX {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LPCWAVEFORMATEX(pub *const WAVEFORMATEX);
impl ::std::ops::Deref for LPCWAVEFORMATEX {
    type Target = *const WAVEFORMATEX;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for LPCWAVEFORMATEX {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_DX8_CHORUS {
    pub fWetDryMix: f32,
    pub fDepth: f32,
    pub fFeedback: f32,
    pub fFrequency: f32,
    #[doc = " 0=triangle, 1=sine"]
    pub lWaveform: DWORD,
    pub fDelay: f32,
    #[doc = " BASS_DX8_PHASE_xxx"]
    pub lPhase: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_DX8_CHORUS() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DX8_CHORUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_CHORUS>(),
        28usize,
        concat!("Size of: ", stringify!(BASS_DX8_CHORUS))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_CHORUS>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_CHORUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fWetDryMix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_CHORUS),
            "::",
            stringify!(fWetDryMix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDepth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_CHORUS),
            "::",
            stringify!(fDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFeedback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_CHORUS),
            "::",
            stringify!(fFeedback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFrequency) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_CHORUS),
            "::",
            stringify!(fFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lWaveform) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_CHORUS),
            "::",
            stringify!(lWaveform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDelay) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_CHORUS),
            "::",
            stringify!(fDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lPhase) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_CHORUS),
            "::",
            stringify!(lPhase)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_DX8_COMPRESSOR {
    pub fGain: f32,
    pub fAttack: f32,
    pub fRelease: f32,
    pub fThreshold: f32,
    pub fRatio: f32,
    pub fPredelay: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_COMPRESSOR() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DX8_COMPRESSOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_COMPRESSOR>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_DX8_COMPRESSOR))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_COMPRESSOR>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_COMPRESSOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAttack) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fAttack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fRelease) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fRelease)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fThreshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fRatio) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fPredelay) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fPredelay)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_DX8_DISTORTION {
    pub fGain: f32,
    pub fEdge: f32,
    pub fPostEQCenterFrequency: f32,
    pub fPostEQBandwidth: f32,
    pub fPreLowpassCutoff: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_DISTORTION() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DX8_DISTORTION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_DISTORTION>(),
        20usize,
        concat!("Size of: ", stringify!(BASS_DX8_DISTORTION))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_DISTORTION>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_DISTORTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_DISTORTION),
            "::",
            stringify!(fGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fEdge) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_DISTORTION),
            "::",
            stringify!(fEdge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fPostEQCenterFrequency) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_DISTORTION),
            "::",
            stringify!(fPostEQCenterFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fPostEQBandwidth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_DISTORTION),
            "::",
            stringify!(fPostEQBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fPreLowpassCutoff) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_DISTORTION),
            "::",
            stringify!(fPreLowpassCutoff)
        )
    );
}
#[repr(C)]
pub struct BASS_DX8_ECHO {
    pub fWetDryMix: f32,
    pub fFeedback: f32,
    pub fLeftDelay: f32,
    pub fRightDelay: f32,
    pub lPanDelay: BOOL,
}
#[test]
fn bindgen_test_layout_BASS_DX8_ECHO() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DX8_ECHO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_ECHO>(),
        20usize,
        concat!("Size of: ", stringify!(BASS_DX8_ECHO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_ECHO>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_ECHO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fWetDryMix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_ECHO),
            "::",
            stringify!(fWetDryMix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFeedback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_ECHO),
            "::",
            stringify!(fFeedback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fLeftDelay) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_ECHO),
            "::",
            stringify!(fLeftDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fRightDelay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_ECHO),
            "::",
            stringify!(fRightDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lPanDelay) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_ECHO),
            "::",
            stringify!(lPanDelay)
        )
    );
}
impl Default for BASS_DX8_ECHO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for BASS_DX8_ECHO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "BASS_DX8_ECHO {{ fWetDryMix: {:?}, fFeedback: {:?}, fLeftDelay: {:?}, fRightDelay: {:?} }}" , self . fWetDryMix , self . fFeedback , self . fLeftDelay , self . fRightDelay)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_DX8_FLANGER {
    pub fWetDryMix: f32,
    pub fDepth: f32,
    pub fFeedback: f32,
    pub fFrequency: f32,
    #[doc = " 0=triangle, 1=sine"]
    pub lWaveform: DWORD,
    pub fDelay: f32,
    #[doc = " BASS_DX8_PHASE_xxx"]
    pub lPhase: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_DX8_FLANGER() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DX8_FLANGER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_FLANGER>(),
        28usize,
        concat!("Size of: ", stringify!(BASS_DX8_FLANGER))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_FLANGER>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_FLANGER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fWetDryMix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_FLANGER),
            "::",
            stringify!(fWetDryMix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDepth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_FLANGER),
            "::",
            stringify!(fDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFeedback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_FLANGER),
            "::",
            stringify!(fFeedback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFrequency) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_FLANGER),
            "::",
            stringify!(fFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lWaveform) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_FLANGER),
            "::",
            stringify!(lWaveform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDelay) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_FLANGER),
            "::",
            stringify!(fDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lPhase) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_FLANGER),
            "::",
            stringify!(lPhase)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BASS_DX8_GARGLE {
    #[doc = " Rate of modulation in hz"]
    pub dwRateHz: DWORD,
    #[doc = " 0=triangle, 1=square"]
    pub dwWaveShape: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_DX8_GARGLE() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DX8_GARGLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_GARGLE>(),
        8usize,
        concat!("Size of: ", stringify!(BASS_DX8_GARGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_GARGLE>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_GARGLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwRateHz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_GARGLE),
            "::",
            stringify!(dwRateHz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwWaveShape) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_GARGLE),
            "::",
            stringify!(dwWaveShape)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_DX8_I3DL2REVERB {
    #[doc = " [-10000, 0]      default: -1000 mB"]
    pub lRoom: ::std::os::raw::c_int,
    #[doc = " [-10000, 0]      default: 0 mB"]
    pub lRoomHF: ::std::os::raw::c_int,
    #[doc = " [0.0, 10.0]      default: 0.0"]
    pub flRoomRolloffFactor: f32,
    #[doc = " [0.1, 20.0]      default: 1.49s"]
    pub flDecayTime: f32,
    #[doc = " [0.1, 2.0]       default: 0.83"]
    pub flDecayHFRatio: f32,
    #[doc = " [-10000, 1000]   default: -2602 mB"]
    pub lReflections: ::std::os::raw::c_int,
    #[doc = " [0.0, 0.3]       default: 0.007 s"]
    pub flReflectionsDelay: f32,
    #[doc = " [-10000, 2000]   default: 200 mB"]
    pub lReverb: ::std::os::raw::c_int,
    #[doc = " [0.0, 0.1]       default: 0.011 s"]
    pub flReverbDelay: f32,
    #[doc = " [0.0, 100.0]     default: 100.0 %"]
    pub flDiffusion: f32,
    #[doc = " [0.0, 100.0]     default: 100.0 %"]
    pub flDensity: f32,
    #[doc = " [20.0, 20000.0]  default: 5000.0 Hz"]
    pub flHFReference: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_I3DL2REVERB() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DX8_I3DL2REVERB> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_I3DL2REVERB>(),
        48usize,
        concat!("Size of: ", stringify!(BASS_DX8_I3DL2REVERB))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_I3DL2REVERB>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_I3DL2REVERB))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lRoom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(lRoom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lRoomHF) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(lRoomHF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flRoomRolloffFactor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flRoomRolloffFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flDecayTime) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flDecayTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flDecayHFRatio) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flDecayHFRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lReflections) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(lReflections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flReflectionsDelay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flReflectionsDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lReverb) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(lReverb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flReverbDelay) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flReverbDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flDiffusion) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flDiffusion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flDensity) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flDensity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flHFReference) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flHFReference)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_DX8_PARAMEQ {
    pub fCenter: f32,
    pub fBandwidth: f32,
    pub fGain: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_PARAMEQ() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DX8_PARAMEQ> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_PARAMEQ>(),
        12usize,
        concat!("Size of: ", stringify!(BASS_DX8_PARAMEQ))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_PARAMEQ>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_PARAMEQ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fCenter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_PARAMEQ),
            "::",
            stringify!(fCenter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBandwidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_PARAMEQ),
            "::",
            stringify!(fBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_PARAMEQ),
            "::",
            stringify!(fGain)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_DX8_REVERB {
    #[doc = " [-96.0,0.0]            default: 0.0 dB"]
    pub fInGain: f32,
    #[doc = " [-96.0,0.0]            default: 0.0 db"]
    pub fReverbMix: f32,
    #[doc = " [0.001,3000.0]         default: 1000.0 ms"]
    pub fReverbTime: f32,
    #[doc = " [0.001,0.999]          default: 0.001"]
    pub fHighFreqRTRatio: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_REVERB() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_DX8_REVERB> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_REVERB>(),
        16usize,
        concat!("Size of: ", stringify!(BASS_DX8_REVERB))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_REVERB>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_REVERB))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fInGain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_REVERB),
            "::",
            stringify!(fInGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fReverbMix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_REVERB),
            "::",
            stringify!(fReverbMix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fReverbTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_REVERB),
            "::",
            stringify!(fReverbTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fHighFreqRTRatio) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_REVERB),
            "::",
            stringify!(fHighFreqRTRatio)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BASS_FX_VOLUME_PARAM {
    pub fTarget: f32,
    pub fCurrent: f32,
    pub fTime: f32,
    pub lCurve: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_FX_VOLUME_PARAM() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_FX_VOLUME_PARAM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_FX_VOLUME_PARAM>(),
        16usize,
        concat!("Size of: ", stringify!(BASS_FX_VOLUME_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_FX_VOLUME_PARAM>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_FX_VOLUME_PARAM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTarget) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FX_VOLUME_PARAM),
            "::",
            stringify!(fTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fCurrent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FX_VOLUME_PARAM),
            "::",
            stringify!(fCurrent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FX_VOLUME_PARAM),
            "::",
            stringify!(fTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lCurve) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FX_VOLUME_PARAM),
            "::",
            stringify!(lCurve)
        )
    );
}
pub type IOSNOTIFYPROC = ::std::option::Option<unsafe extern "C" fn(status: DWORD)>;
extern crate libloading;
pub struct BASS {
    __library: ::libloading::Library,
    pub BASS_SetConfig: unsafe extern "C" fn(option: DWORD, value: DWORD) -> BOOL,
    pub BASS_GetConfig: unsafe extern "C" fn(option: DWORD) -> DWORD,
    pub BASS_SetConfigPtr:
        unsafe extern "C" fn(option: DWORD, value: *const ::std::os::raw::c_void) -> BOOL,
    pub BASS_GetConfigPtr: unsafe extern "C" fn(option: DWORD) -> *const ::std::os::raw::c_void,
    pub BASS_GetVersion: unsafe extern "C" fn() -> DWORD,
    pub BASS_ErrorGetCode: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub BASS_GetDeviceInfo: unsafe extern "C" fn(device: DWORD, info: *mut BASS_DEVICEINFO) -> BOOL,
    pub BASS_Init: unsafe extern "C" fn(
        device: ::std::os::raw::c_int,
        freq: DWORD,
        flags: DWORD,
        win: *mut ::std::os::raw::c_void,
        dsguid: *const ::std::os::raw::c_void,
    ) -> BOOL,
    pub BASS_Free: unsafe extern "C" fn() -> BOOL,
    pub BASS_SetDevice: unsafe extern "C" fn(device: DWORD) -> BOOL,
    pub BASS_GetDevice: unsafe extern "C" fn() -> DWORD,
    pub BASS_GetInfo: unsafe extern "C" fn(info: *mut BASS_INFO) -> BOOL,
    pub BASS_Start: unsafe extern "C" fn() -> BOOL,
    pub BASS_Stop: unsafe extern "C" fn() -> BOOL,
    pub BASS_Pause: unsafe extern "C" fn() -> BOOL,
    pub BASS_IsStarted: unsafe extern "C" fn() -> DWORD,
    pub BASS_Update: unsafe extern "C" fn(length: DWORD) -> BOOL,
    pub BASS_GetCPU: unsafe extern "C" fn() -> f32,
    pub BASS_SetVolume: unsafe extern "C" fn(volume: f32) -> BOOL,
    pub BASS_GetVolume: unsafe extern "C" fn() -> f32,
    pub BASS_Set3DFactors: unsafe extern "C" fn(distf: f32, rollf: f32, doppf: f32) -> BOOL,
    pub BASS_Get3DFactors:
        unsafe extern "C" fn(distf: *mut f32, rollf: *mut f32, doppf: *mut f32) -> BOOL,
    pub BASS_Set3DPosition: unsafe extern "C" fn(
        pos: *const BASS_3DVECTOR,
        vel: *const BASS_3DVECTOR,
        front: *const BASS_3DVECTOR,
        top: *const BASS_3DVECTOR,
    ) -> BOOL,
    pub BASS_Get3DPosition: unsafe extern "C" fn(
        pos: *mut BASS_3DVECTOR,
        vel: *mut BASS_3DVECTOR,
        front: *mut BASS_3DVECTOR,
        top: *mut BASS_3DVECTOR,
    ) -> BOOL,
    pub BASS_Apply3D: unsafe extern "C" fn(),
    pub BASS_PluginLoad:
        unsafe extern "C" fn(file: *const ::std::os::raw::c_char, flags: DWORD) -> HPLUGIN,
    pub BASS_PluginFree: unsafe extern "C" fn(handle: HPLUGIN) -> BOOL,
    pub BASS_PluginEnable: unsafe extern "C" fn(handle: HPLUGIN, enable: BOOL) -> BOOL,
    pub BASS_PluginGetInfo: unsafe extern "C" fn(handle: HPLUGIN) -> *const BASS_PLUGININFO,
    pub BASS_SampleLoad: unsafe extern "C" fn(
        mem: BOOL,
        file: *const ::std::os::raw::c_void,
        offset: QWORD,
        length: DWORD,
        max: DWORD,
        flags: DWORD,
    ) -> HSAMPLE,
    pub BASS_SampleCreate: unsafe extern "C" fn(
        length: DWORD,
        freq: DWORD,
        chans: DWORD,
        max: DWORD,
        flags: DWORD,
    ) -> HSAMPLE,
    pub BASS_SampleFree: unsafe extern "C" fn(handle: HSAMPLE) -> BOOL,
    pub BASS_SampleSetData:
        unsafe extern "C" fn(handle: HSAMPLE, buffer: *const ::std::os::raw::c_void) -> BOOL,
    pub BASS_SampleGetData:
        unsafe extern "C" fn(handle: HSAMPLE, buffer: *mut ::std::os::raw::c_void) -> BOOL,
    pub BASS_SampleGetInfo: unsafe extern "C" fn(handle: HSAMPLE, info: *mut BASS_SAMPLE) -> BOOL,
    pub BASS_SampleSetInfo: unsafe extern "C" fn(handle: HSAMPLE, info: *const BASS_SAMPLE) -> BOOL,
    pub BASS_SampleGetChannel: unsafe extern "C" fn(handle: HSAMPLE, flags: DWORD) -> DWORD,
    pub BASS_SampleGetChannels:
        unsafe extern "C" fn(handle: HSAMPLE, channels: *mut HCHANNEL) -> DWORD,
    pub BASS_SampleStop: unsafe extern "C" fn(handle: HSAMPLE) -> BOOL,
    pub BASS_StreamCreate: unsafe extern "C" fn(
        freq: DWORD,
        chans: DWORD,
        flags: DWORD,
        proc_: STREAMPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM,
    pub BASS_StreamCreateFile: unsafe extern "C" fn(
        mem: BOOL,
        file: *const ::std::os::raw::c_void,
        offset: QWORD,
        length: QWORD,
        flags: DWORD,
    ) -> HSTREAM,
    pub BASS_StreamCreateURL: unsafe extern "C" fn(
        url: *const ::std::os::raw::c_char,
        offset: DWORD,
        flags: DWORD,
        proc_: DOWNLOADPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM,
    pub BASS_StreamCreateFileUser: unsafe extern "C" fn(
        system: DWORD,
        flags: DWORD,
        proc_: *const BASS_FILEPROCS,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM,
    pub BASS_StreamFree: unsafe extern "C" fn(handle: HSTREAM) -> BOOL,
    pub BASS_StreamGetFilePosition: unsafe extern "C" fn(handle: HSTREAM, mode: DWORD) -> QWORD,
    pub BASS_StreamPutData: unsafe extern "C" fn(
        handle: HSTREAM,
        buffer: *const ::std::os::raw::c_void,
        length: DWORD,
    ) -> DWORD,
    pub BASS_StreamPutFileData: unsafe extern "C" fn(
        handle: HSTREAM,
        buffer: *const ::std::os::raw::c_void,
        length: DWORD,
    ) -> DWORD,
    pub BASS_MusicLoad: unsafe extern "C" fn(
        mem: BOOL,
        file: *const ::std::os::raw::c_void,
        offset: QWORD,
        length: DWORD,
        flags: DWORD,
        freq: DWORD,
    ) -> HMUSIC,
    pub BASS_MusicFree: unsafe extern "C" fn(handle: HMUSIC) -> BOOL,
    pub BASS_RecordGetDeviceInfo:
        unsafe extern "C" fn(device: DWORD, info: *mut BASS_DEVICEINFO) -> BOOL,
    pub BASS_RecordInit: unsafe extern "C" fn(device: ::std::os::raw::c_int) -> BOOL,
    pub BASS_RecordFree: unsafe extern "C" fn() -> BOOL,
    pub BASS_RecordSetDevice: unsafe extern "C" fn(device: DWORD) -> BOOL,
    pub BASS_RecordGetDevice: unsafe extern "C" fn() -> DWORD,
    pub BASS_RecordGetInfo: unsafe extern "C" fn(info: *mut BASS_RECORDINFO) -> BOOL,
    pub BASS_RecordGetInputName:
        unsafe extern "C" fn(input: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
    pub BASS_RecordSetInput:
        unsafe extern "C" fn(input: ::std::os::raw::c_int, flags: DWORD, volume: f32) -> BOOL,
    pub BASS_RecordGetInput:
        unsafe extern "C" fn(input: ::std::os::raw::c_int, volume: *mut f32) -> DWORD,
    pub BASS_RecordStart: unsafe extern "C" fn(
        freq: DWORD,
        chans: DWORD,
        flags: DWORD,
        proc_: RECORDPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HRECORD,
    pub BASS_ChannelBytes2Seconds: unsafe extern "C" fn(handle: DWORD, pos: QWORD) -> f64,
    pub BASS_ChannelSeconds2Bytes: unsafe extern "C" fn(handle: DWORD, pos: f64) -> QWORD,
    pub BASS_ChannelGetDevice: unsafe extern "C" fn(handle: DWORD) -> DWORD,
    pub BASS_ChannelSetDevice: unsafe extern "C" fn(handle: DWORD, device: DWORD) -> BOOL,
    pub BASS_ChannelIsActive: unsafe extern "C" fn(handle: DWORD) -> DWORD,
    pub BASS_ChannelGetInfo:
        unsafe extern "C" fn(handle: DWORD, info: *mut BASS_CHANNELINFO) -> BOOL,
    pub BASS_ChannelGetTags:
        unsafe extern "C" fn(handle: DWORD, tags: DWORD) -> *const ::std::os::raw::c_char,
    pub BASS_ChannelFlags: unsafe extern "C" fn(handle: DWORD, flags: DWORD, mask: DWORD) -> DWORD,
    pub BASS_ChannelLock: unsafe extern "C" fn(handle: DWORD, lock: BOOL) -> BOOL,
    pub BASS_ChannelFree: unsafe extern "C" fn(handle: DWORD) -> BOOL,
    pub BASS_ChannelPlay: unsafe extern "C" fn(handle: DWORD, restart: BOOL) -> BOOL,
    pub BASS_ChannelStart: unsafe extern "C" fn(handle: DWORD) -> BOOL,
    pub BASS_ChannelStop: unsafe extern "C" fn(handle: DWORD) -> BOOL,
    pub BASS_ChannelPause: unsafe extern "C" fn(handle: DWORD) -> BOOL,
    pub BASS_ChannelUpdate: unsafe extern "C" fn(handle: DWORD, length: DWORD) -> BOOL,
    pub BASS_ChannelSetAttribute:
        unsafe extern "C" fn(handle: DWORD, attrib: DWORD, value: f32) -> BOOL,
    pub BASS_ChannelGetAttribute:
        unsafe extern "C" fn(handle: DWORD, attrib: DWORD, value: *mut f32) -> BOOL,
    pub BASS_ChannelSlideAttribute:
        unsafe extern "C" fn(handle: DWORD, attrib: DWORD, value: f32, time: DWORD) -> BOOL,
    pub BASS_ChannelIsSliding: unsafe extern "C" fn(handle: DWORD, attrib: DWORD) -> BOOL,
    pub BASS_ChannelSetAttributeEx: unsafe extern "C" fn(
        handle: DWORD,
        attrib: DWORD,
        value: *mut ::std::os::raw::c_void,
        size: DWORD,
    ) -> BOOL,
    pub BASS_ChannelGetAttributeEx: unsafe extern "C" fn(
        handle: DWORD,
        attrib: DWORD,
        value: *mut ::std::os::raw::c_void,
        size: DWORD,
    ) -> DWORD,
    pub BASS_ChannelSet3DAttributes: unsafe extern "C" fn(
        handle: DWORD,
        mode: ::std::os::raw::c_int,
        min: f32,
        max: f32,
        iangle: ::std::os::raw::c_int,
        oangle: ::std::os::raw::c_int,
        outvol: f32,
    ) -> BOOL,
    pub BASS_ChannelGet3DAttributes: unsafe extern "C" fn(
        handle: DWORD,
        mode: *mut DWORD,
        min: *mut f32,
        max: *mut f32,
        iangle: *mut DWORD,
        oangle: *mut DWORD,
        outvol: *mut f32,
    ) -> BOOL,
    pub BASS_ChannelSet3DPosition: unsafe extern "C" fn(
        handle: DWORD,
        pos: *const BASS_3DVECTOR,
        orient: *const BASS_3DVECTOR,
        vel: *const BASS_3DVECTOR,
    ) -> BOOL,
    pub BASS_ChannelGet3DPosition: unsafe extern "C" fn(
        handle: DWORD,
        pos: *mut BASS_3DVECTOR,
        orient: *mut BASS_3DVECTOR,
        vel: *mut BASS_3DVECTOR,
    ) -> BOOL,
    pub BASS_ChannelGetLength: unsafe extern "C" fn(handle: DWORD, mode: DWORD) -> QWORD,
    pub BASS_ChannelSetPosition:
        unsafe extern "C" fn(handle: DWORD, pos: QWORD, mode: DWORD) -> BOOL,
    pub BASS_ChannelGetPosition: unsafe extern "C" fn(handle: DWORD, mode: DWORD) -> QWORD,
    pub BASS_ChannelGetLevel: unsafe extern "C" fn(handle: DWORD) -> DWORD,
    pub BASS_ChannelGetLevelEx:
        unsafe extern "C" fn(handle: DWORD, levels: *mut f32, length: f32, flags: DWORD) -> BOOL,
    pub BASS_ChannelGetData: unsafe extern "C" fn(
        handle: DWORD,
        buffer: *mut ::std::os::raw::c_void,
        length: DWORD,
    ) -> DWORD,
    pub BASS_ChannelSetSync: unsafe extern "C" fn(
        handle: DWORD,
        type_: DWORD,
        param: QWORD,
        proc_: SYNCPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSYNC,
    pub BASS_ChannelRemoveSync: unsafe extern "C" fn(handle: DWORD, sync: HSYNC) -> BOOL,
    pub BASS_ChannelSetLink: unsafe extern "C" fn(handle: DWORD, chan: DWORD) -> BOOL,
    pub BASS_ChannelRemoveLink: unsafe extern "C" fn(handle: DWORD, chan: DWORD) -> BOOL,
    pub BASS_ChannelSetDSP: unsafe extern "C" fn(
        handle: DWORD,
        proc_: DSPPROC,
        user: *mut ::std::os::raw::c_void,
        priority: ::std::os::raw::c_int,
    ) -> HDSP,
    pub BASS_ChannelRemoveDSP: unsafe extern "C" fn(handle: DWORD, dsp: HDSP) -> BOOL,
    pub BASS_ChannelSetFX:
        unsafe extern "C" fn(handle: DWORD, type_: DWORD, priority: ::std::os::raw::c_int) -> HFX,
    pub BASS_ChannelRemoveFX: unsafe extern "C" fn(handle: DWORD, fx: HFX) -> BOOL,
    pub BASS_FXSetParameters:
        unsafe extern "C" fn(handle: HFX, params: *const ::std::os::raw::c_void) -> BOOL,
    pub BASS_FXGetParameters:
        unsafe extern "C" fn(handle: HFX, params: *mut ::std::os::raw::c_void) -> BOOL,
    pub BASS_FXSetPriority:
        unsafe extern "C" fn(handle: HFX, priority: ::std::os::raw::c_int) -> BOOL,
    pub BASS_FXReset: unsafe extern "C" fn(handle: DWORD) -> BOOL,
}
impl BASS {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let BASS_SetConfig = __library.get(b"BASS_SetConfig\0").map(|sym| *sym)?;
        let BASS_GetConfig = __library.get(b"BASS_GetConfig\0").map(|sym| *sym)?;
        let BASS_SetConfigPtr = __library.get(b"BASS_SetConfigPtr\0").map(|sym| *sym)?;
        let BASS_GetConfigPtr = __library.get(b"BASS_GetConfigPtr\0").map(|sym| *sym)?;
        let BASS_GetVersion = __library.get(b"BASS_GetVersion\0").map(|sym| *sym)?;
        let BASS_ErrorGetCode = __library.get(b"BASS_ErrorGetCode\0").map(|sym| *sym)?;
        let BASS_GetDeviceInfo = __library.get(b"BASS_GetDeviceInfo\0").map(|sym| *sym)?;
        let BASS_Init = __library.get(b"BASS_Init\0").map(|sym| *sym)?;
        let BASS_Free = __library.get(b"BASS_Free\0").map(|sym| *sym)?;
        let BASS_SetDevice = __library.get(b"BASS_SetDevice\0").map(|sym| *sym)?;
        let BASS_GetDevice = __library.get(b"BASS_GetDevice\0").map(|sym| *sym)?;
        let BASS_GetInfo = __library.get(b"BASS_GetInfo\0").map(|sym| *sym)?;
        let BASS_Start = __library.get(b"BASS_Start\0").map(|sym| *sym)?;
        let BASS_Stop = __library.get(b"BASS_Stop\0").map(|sym| *sym)?;
        let BASS_Pause = __library.get(b"BASS_Pause\0").map(|sym| *sym)?;
        let BASS_IsStarted = __library.get(b"BASS_IsStarted\0").map(|sym| *sym)?;
        let BASS_Update = __library.get(b"BASS_Update\0").map(|sym| *sym)?;
        let BASS_GetCPU = __library.get(b"BASS_GetCPU\0").map(|sym| *sym)?;
        let BASS_SetVolume = __library.get(b"BASS_SetVolume\0").map(|sym| *sym)?;
        let BASS_GetVolume = __library.get(b"BASS_GetVolume\0").map(|sym| *sym)?;
        let BASS_Set3DFactors = __library.get(b"BASS_Set3DFactors\0").map(|sym| *sym)?;
        let BASS_Get3DFactors = __library.get(b"BASS_Get3DFactors\0").map(|sym| *sym)?;
        let BASS_Set3DPosition = __library.get(b"BASS_Set3DPosition\0").map(|sym| *sym)?;
        let BASS_Get3DPosition = __library.get(b"BASS_Get3DPosition\0").map(|sym| *sym)?;
        let BASS_Apply3D = __library.get(b"BASS_Apply3D\0").map(|sym| *sym)?;
        let BASS_PluginLoad = __library.get(b"BASS_PluginLoad\0").map(|sym| *sym)?;
        let BASS_PluginFree = __library.get(b"BASS_PluginFree\0").map(|sym| *sym)?;
        let BASS_PluginEnable = __library.get(b"BASS_PluginEnable\0").map(|sym| *sym)?;
        let BASS_PluginGetInfo = __library.get(b"BASS_PluginGetInfo\0").map(|sym| *sym)?;
        let BASS_SampleLoad = __library.get(b"BASS_SampleLoad\0").map(|sym| *sym)?;
        let BASS_SampleCreate = __library.get(b"BASS_SampleCreate\0").map(|sym| *sym)?;
        let BASS_SampleFree = __library.get(b"BASS_SampleFree\0").map(|sym| *sym)?;
        let BASS_SampleSetData = __library.get(b"BASS_SampleSetData\0").map(|sym| *sym)?;
        let BASS_SampleGetData = __library.get(b"BASS_SampleGetData\0").map(|sym| *sym)?;
        let BASS_SampleGetInfo = __library.get(b"BASS_SampleGetInfo\0").map(|sym| *sym)?;
        let BASS_SampleSetInfo = __library.get(b"BASS_SampleSetInfo\0").map(|sym| *sym)?;
        let BASS_SampleGetChannel = __library.get(b"BASS_SampleGetChannel\0").map(|sym| *sym)?;
        let BASS_SampleGetChannels = __library.get(b"BASS_SampleGetChannels\0").map(|sym| *sym)?;
        let BASS_SampleStop = __library.get(b"BASS_SampleStop\0").map(|sym| *sym)?;
        let BASS_StreamCreate = __library.get(b"BASS_StreamCreate\0").map(|sym| *sym)?;
        let BASS_StreamCreateFile = __library.get(b"BASS_StreamCreateFile\0").map(|sym| *sym)?;
        let BASS_StreamCreateURL = __library.get(b"BASS_StreamCreateURL\0").map(|sym| *sym)?;
        let BASS_StreamCreateFileUser = __library
            .get(b"BASS_StreamCreateFileUser\0")
            .map(|sym| *sym)?;
        let BASS_StreamFree = __library.get(b"BASS_StreamFree\0").map(|sym| *sym)?;
        let BASS_StreamGetFilePosition = __library
            .get(b"BASS_StreamGetFilePosition\0")
            .map(|sym| *sym)?;
        let BASS_StreamPutData = __library.get(b"BASS_StreamPutData\0").map(|sym| *sym)?;
        let BASS_StreamPutFileData = __library.get(b"BASS_StreamPutFileData\0").map(|sym| *sym)?;
        let BASS_MusicLoad = __library.get(b"BASS_MusicLoad\0").map(|sym| *sym)?;
        let BASS_MusicFree = __library.get(b"BASS_MusicFree\0").map(|sym| *sym)?;
        let BASS_RecordGetDeviceInfo = __library
            .get(b"BASS_RecordGetDeviceInfo\0")
            .map(|sym| *sym)?;
        let BASS_RecordInit = __library.get(b"BASS_RecordInit\0").map(|sym| *sym)?;
        let BASS_RecordFree = __library.get(b"BASS_RecordFree\0").map(|sym| *sym)?;
        let BASS_RecordSetDevice = __library.get(b"BASS_RecordSetDevice\0").map(|sym| *sym)?;
        let BASS_RecordGetDevice = __library.get(b"BASS_RecordGetDevice\0").map(|sym| *sym)?;
        let BASS_RecordGetInfo = __library.get(b"BASS_RecordGetInfo\0").map(|sym| *sym)?;
        let BASS_RecordGetInputName = __library
            .get(b"BASS_RecordGetInputName\0")
            .map(|sym| *sym)?;
        let BASS_RecordSetInput = __library.get(b"BASS_RecordSetInput\0").map(|sym| *sym)?;
        let BASS_RecordGetInput = __library.get(b"BASS_RecordGetInput\0").map(|sym| *sym)?;
        let BASS_RecordStart = __library.get(b"BASS_RecordStart\0").map(|sym| *sym)?;
        let BASS_ChannelBytes2Seconds = __library
            .get(b"BASS_ChannelBytes2Seconds\0")
            .map(|sym| *sym)?;
        let BASS_ChannelSeconds2Bytes = __library
            .get(b"BASS_ChannelSeconds2Bytes\0")
            .map(|sym| *sym)?;
        let BASS_ChannelGetDevice = __library.get(b"BASS_ChannelGetDevice\0").map(|sym| *sym)?;
        let BASS_ChannelSetDevice = __library.get(b"BASS_ChannelSetDevice\0").map(|sym| *sym)?;
        let BASS_ChannelIsActive = __library.get(b"BASS_ChannelIsActive\0").map(|sym| *sym)?;
        let BASS_ChannelGetInfo = __library.get(b"BASS_ChannelGetInfo\0").map(|sym| *sym)?;
        let BASS_ChannelGetTags = __library.get(b"BASS_ChannelGetTags\0").map(|sym| *sym)?;
        let BASS_ChannelFlags = __library.get(b"BASS_ChannelFlags\0").map(|sym| *sym)?;
        let BASS_ChannelLock = __library.get(b"BASS_ChannelLock\0").map(|sym| *sym)?;
        let BASS_ChannelFree = __library.get(b"BASS_ChannelFree\0").map(|sym| *sym)?;
        let BASS_ChannelPlay = __library.get(b"BASS_ChannelPlay\0").map(|sym| *sym)?;
        let BASS_ChannelStart = __library.get(b"BASS_ChannelStart\0").map(|sym| *sym)?;
        let BASS_ChannelStop = __library.get(b"BASS_ChannelStop\0").map(|sym| *sym)?;
        let BASS_ChannelPause = __library.get(b"BASS_ChannelPause\0").map(|sym| *sym)?;
        let BASS_ChannelUpdate = __library.get(b"BASS_ChannelUpdate\0").map(|sym| *sym)?;
        let BASS_ChannelSetAttribute = __library
            .get(b"BASS_ChannelSetAttribute\0")
            .map(|sym| *sym)?;
        let BASS_ChannelGetAttribute = __library
            .get(b"BASS_ChannelGetAttribute\0")
            .map(|sym| *sym)?;
        let BASS_ChannelSlideAttribute = __library
            .get(b"BASS_ChannelSlideAttribute\0")
            .map(|sym| *sym)?;
        let BASS_ChannelIsSliding = __library.get(b"BASS_ChannelIsSliding\0").map(|sym| *sym)?;
        let BASS_ChannelSetAttributeEx = __library
            .get(b"BASS_ChannelSetAttributeEx\0")
            .map(|sym| *sym)?;
        let BASS_ChannelGetAttributeEx = __library
            .get(b"BASS_ChannelGetAttributeEx\0")
            .map(|sym| *sym)?;
        let BASS_ChannelSet3DAttributes = __library
            .get(b"BASS_ChannelSet3DAttributes\0")
            .map(|sym| *sym)?;
        let BASS_ChannelGet3DAttributes = __library
            .get(b"BASS_ChannelGet3DAttributes\0")
            .map(|sym| *sym)?;
        let BASS_ChannelSet3DPosition = __library
            .get(b"BASS_ChannelSet3DPosition\0")
            .map(|sym| *sym)?;
        let BASS_ChannelGet3DPosition = __library
            .get(b"BASS_ChannelGet3DPosition\0")
            .map(|sym| *sym)?;
        let BASS_ChannelGetLength = __library.get(b"BASS_ChannelGetLength\0").map(|sym| *sym)?;
        let BASS_ChannelSetPosition = __library
            .get(b"BASS_ChannelSetPosition\0")
            .map(|sym| *sym)?;
        let BASS_ChannelGetPosition = __library
            .get(b"BASS_ChannelGetPosition\0")
            .map(|sym| *sym)?;
        let BASS_ChannelGetLevel = __library.get(b"BASS_ChannelGetLevel\0").map(|sym| *sym)?;
        let BASS_ChannelGetLevelEx = __library.get(b"BASS_ChannelGetLevelEx\0").map(|sym| *sym)?;
        let BASS_ChannelGetData = __library.get(b"BASS_ChannelGetData\0").map(|sym| *sym)?;
        let BASS_ChannelSetSync = __library.get(b"BASS_ChannelSetSync\0").map(|sym| *sym)?;
        let BASS_ChannelRemoveSync = __library.get(b"BASS_ChannelRemoveSync\0").map(|sym| *sym)?;
        let BASS_ChannelSetLink = __library.get(b"BASS_ChannelSetLink\0").map(|sym| *sym)?;
        let BASS_ChannelRemoveLink = __library.get(b"BASS_ChannelRemoveLink\0").map(|sym| *sym)?;
        let BASS_ChannelSetDSP = __library.get(b"BASS_ChannelSetDSP\0").map(|sym| *sym)?;
        let BASS_ChannelRemoveDSP = __library.get(b"BASS_ChannelRemoveDSP\0").map(|sym| *sym)?;
        let BASS_ChannelSetFX = __library.get(b"BASS_ChannelSetFX\0").map(|sym| *sym)?;
        let BASS_ChannelRemoveFX = __library.get(b"BASS_ChannelRemoveFX\0").map(|sym| *sym)?;
        let BASS_FXSetParameters = __library.get(b"BASS_FXSetParameters\0").map(|sym| *sym)?;
        let BASS_FXGetParameters = __library.get(b"BASS_FXGetParameters\0").map(|sym| *sym)?;
        let BASS_FXSetPriority = __library.get(b"BASS_FXSetPriority\0").map(|sym| *sym)?;
        let BASS_FXReset = __library.get(b"BASS_FXReset\0").map(|sym| *sym)?;
        Ok(BASS {
            __library,
            BASS_SetConfig,
            BASS_GetConfig,
            BASS_SetConfigPtr,
            BASS_GetConfigPtr,
            BASS_GetVersion,
            BASS_ErrorGetCode,
            BASS_GetDeviceInfo,
            BASS_Init,
            BASS_Free,
            BASS_SetDevice,
            BASS_GetDevice,
            BASS_GetInfo,
            BASS_Start,
            BASS_Stop,
            BASS_Pause,
            BASS_IsStarted,
            BASS_Update,
            BASS_GetCPU,
            BASS_SetVolume,
            BASS_GetVolume,
            BASS_Set3DFactors,
            BASS_Get3DFactors,
            BASS_Set3DPosition,
            BASS_Get3DPosition,
            BASS_Apply3D,
            BASS_PluginLoad,
            BASS_PluginFree,
            BASS_PluginEnable,
            BASS_PluginGetInfo,
            BASS_SampleLoad,
            BASS_SampleCreate,
            BASS_SampleFree,
            BASS_SampleSetData,
            BASS_SampleGetData,
            BASS_SampleGetInfo,
            BASS_SampleSetInfo,
            BASS_SampleGetChannel,
            BASS_SampleGetChannels,
            BASS_SampleStop,
            BASS_StreamCreate,
            BASS_StreamCreateFile,
            BASS_StreamCreateURL,
            BASS_StreamCreateFileUser,
            BASS_StreamFree,
            BASS_StreamGetFilePosition,
            BASS_StreamPutData,
            BASS_StreamPutFileData,
            BASS_MusicLoad,
            BASS_MusicFree,
            BASS_RecordGetDeviceInfo,
            BASS_RecordInit,
            BASS_RecordFree,
            BASS_RecordSetDevice,
            BASS_RecordGetDevice,
            BASS_RecordGetInfo,
            BASS_RecordGetInputName,
            BASS_RecordSetInput,
            BASS_RecordGetInput,
            BASS_RecordStart,
            BASS_ChannelBytes2Seconds,
            BASS_ChannelSeconds2Bytes,
            BASS_ChannelGetDevice,
            BASS_ChannelSetDevice,
            BASS_ChannelIsActive,
            BASS_ChannelGetInfo,
            BASS_ChannelGetTags,
            BASS_ChannelFlags,
            BASS_ChannelLock,
            BASS_ChannelFree,
            BASS_ChannelPlay,
            BASS_ChannelStart,
            BASS_ChannelStop,
            BASS_ChannelPause,
            BASS_ChannelUpdate,
            BASS_ChannelSetAttribute,
            BASS_ChannelGetAttribute,
            BASS_ChannelSlideAttribute,
            BASS_ChannelIsSliding,
            BASS_ChannelSetAttributeEx,
            BASS_ChannelGetAttributeEx,
            BASS_ChannelSet3DAttributes,
            BASS_ChannelGet3DAttributes,
            BASS_ChannelSet3DPosition,
            BASS_ChannelGet3DPosition,
            BASS_ChannelGetLength,
            BASS_ChannelSetPosition,
            BASS_ChannelGetPosition,
            BASS_ChannelGetLevel,
            BASS_ChannelGetLevelEx,
            BASS_ChannelGetData,
            BASS_ChannelSetSync,
            BASS_ChannelRemoveSync,
            BASS_ChannelSetLink,
            BASS_ChannelRemoveLink,
            BASS_ChannelSetDSP,
            BASS_ChannelRemoveDSP,
            BASS_ChannelSetFX,
            BASS_ChannelRemoveFX,
            BASS_FXSetParameters,
            BASS_FXGetParameters,
            BASS_FXSetPriority,
            BASS_FXReset,
        })
    }
    pub unsafe fn BASS_SetConfig(&self, option: DWORD, value: DWORD) -> BOOL {
        (self.BASS_SetConfig)(option, value)
    }
    pub unsafe fn BASS_GetConfig(&self, option: DWORD) -> DWORD {
        (self.BASS_GetConfig)(option)
    }
    pub unsafe fn BASS_SetConfigPtr(
        &self,
        option: DWORD,
        value: *const ::std::os::raw::c_void,
    ) -> BOOL {
        (self.BASS_SetConfigPtr)(option, value)
    }
    pub unsafe fn BASS_GetConfigPtr(&self, option: DWORD) -> *const ::std::os::raw::c_void {
        (self.BASS_GetConfigPtr)(option)
    }
    pub unsafe fn BASS_GetVersion(&self) -> DWORD {
        (self.BASS_GetVersion)()
    }
    pub unsafe fn BASS_ErrorGetCode(&self) -> ::std::os::raw::c_int {
        (self.BASS_ErrorGetCode)()
    }
    pub unsafe fn BASS_GetDeviceInfo(&self, device: DWORD, info: *mut BASS_DEVICEINFO) -> BOOL {
        (self.BASS_GetDeviceInfo)(device, info)
    }
    pub unsafe fn BASS_Init(
        &self,
        device: ::std::os::raw::c_int,
        freq: DWORD,
        flags: DWORD,
        win: *mut ::std::os::raw::c_void,
        dsguid: *const ::std::os::raw::c_void,
    ) -> BOOL {
        (self.BASS_Init)(device, freq, flags, win, dsguid)
    }
    pub unsafe fn BASS_Free(&self) -> BOOL {
        (self.BASS_Free)()
    }
    pub unsafe fn BASS_SetDevice(&self, device: DWORD) -> BOOL {
        (self.BASS_SetDevice)(device)
    }
    pub unsafe fn BASS_GetDevice(&self) -> DWORD {
        (self.BASS_GetDevice)()
    }
    pub unsafe fn BASS_GetInfo(&self, info: *mut BASS_INFO) -> BOOL {
        (self.BASS_GetInfo)(info)
    }
    pub unsafe fn BASS_Start(&self) -> BOOL {
        (self.BASS_Start)()
    }
    pub unsafe fn BASS_Stop(&self) -> BOOL {
        (self.BASS_Stop)()
    }
    pub unsafe fn BASS_Pause(&self) -> BOOL {
        (self.BASS_Pause)()
    }
    pub unsafe fn BASS_IsStarted(&self) -> DWORD {
        (self.BASS_IsStarted)()
    }
    pub unsafe fn BASS_Update(&self, length: DWORD) -> BOOL {
        (self.BASS_Update)(length)
    }
    pub unsafe fn BASS_GetCPU(&self) -> f32 {
        (self.BASS_GetCPU)()
    }
    pub unsafe fn BASS_SetVolume(&self, volume: f32) -> BOOL {
        (self.BASS_SetVolume)(volume)
    }
    pub unsafe fn BASS_GetVolume(&self) -> f32 {
        (self.BASS_GetVolume)()
    }
    pub unsafe fn BASS_Set3DFactors(&self, distf: f32, rollf: f32, doppf: f32) -> BOOL {
        (self.BASS_Set3DFactors)(distf, rollf, doppf)
    }
    pub unsafe fn BASS_Get3DFactors(
        &self,
        distf: *mut f32,
        rollf: *mut f32,
        doppf: *mut f32,
    ) -> BOOL {
        (self.BASS_Get3DFactors)(distf, rollf, doppf)
    }
    pub unsafe fn BASS_Set3DPosition(
        &self,
        pos: *const BASS_3DVECTOR,
        vel: *const BASS_3DVECTOR,
        front: *const BASS_3DVECTOR,
        top: *const BASS_3DVECTOR,
    ) -> BOOL {
        (self.BASS_Set3DPosition)(pos, vel, front, top)
    }
    pub unsafe fn BASS_Get3DPosition(
        &self,
        pos: *mut BASS_3DVECTOR,
        vel: *mut BASS_3DVECTOR,
        front: *mut BASS_3DVECTOR,
        top: *mut BASS_3DVECTOR,
    ) -> BOOL {
        (self.BASS_Get3DPosition)(pos, vel, front, top)
    }
    pub unsafe fn BASS_Apply3D(&self) {
        (self.BASS_Apply3D)()
    }
    pub unsafe fn BASS_PluginLoad(
        &self,
        file: *const ::std::os::raw::c_char,
        flags: DWORD,
    ) -> HPLUGIN {
        (self.BASS_PluginLoad)(file, flags)
    }
    pub unsafe fn BASS_PluginFree(&self, handle: HPLUGIN) -> BOOL {
        (self.BASS_PluginFree)(handle)
    }
    pub unsafe fn BASS_PluginEnable(&self, handle: HPLUGIN, enable: BOOL) -> BOOL {
        (self.BASS_PluginEnable)(handle, enable)
    }
    pub unsafe fn BASS_PluginGetInfo(&self, handle: HPLUGIN) -> *const BASS_PLUGININFO {
        (self.BASS_PluginGetInfo)(handle)
    }
    pub unsafe fn BASS_SampleLoad(
        &self,
        mem: BOOL,
        file: *const ::std::os::raw::c_void,
        offset: QWORD,
        length: DWORD,
        max: DWORD,
        flags: DWORD,
    ) -> HSAMPLE {
        (self.BASS_SampleLoad)(mem, file, offset, length, max, flags)
    }
    pub unsafe fn BASS_SampleCreate(
        &self,
        length: DWORD,
        freq: DWORD,
        chans: DWORD,
        max: DWORD,
        flags: DWORD,
    ) -> HSAMPLE {
        (self.BASS_SampleCreate)(length, freq, chans, max, flags)
    }
    pub unsafe fn BASS_SampleFree(&self, handle: HSAMPLE) -> BOOL {
        (self.BASS_SampleFree)(handle)
    }
    pub unsafe fn BASS_SampleSetData(
        &self,
        handle: HSAMPLE,
        buffer: *const ::std::os::raw::c_void,
    ) -> BOOL {
        (self.BASS_SampleSetData)(handle, buffer)
    }
    pub unsafe fn BASS_SampleGetData(
        &self,
        handle: HSAMPLE,
        buffer: *mut ::std::os::raw::c_void,
    ) -> BOOL {
        (self.BASS_SampleGetData)(handle, buffer)
    }
    pub unsafe fn BASS_SampleGetInfo(&self, handle: HSAMPLE, info: *mut BASS_SAMPLE) -> BOOL {
        (self.BASS_SampleGetInfo)(handle, info)
    }
    pub unsafe fn BASS_SampleSetInfo(&self, handle: HSAMPLE, info: *const BASS_SAMPLE) -> BOOL {
        (self.BASS_SampleSetInfo)(handle, info)
    }
    pub unsafe fn BASS_SampleGetChannel(&self, handle: HSAMPLE, flags: DWORD) -> DWORD {
        (self.BASS_SampleGetChannel)(handle, flags)
    }
    pub unsafe fn BASS_SampleGetChannels(&self, handle: HSAMPLE, channels: *mut HCHANNEL) -> DWORD {
        (self.BASS_SampleGetChannels)(handle, channels)
    }
    pub unsafe fn BASS_SampleStop(&self, handle: HSAMPLE) -> BOOL {
        (self.BASS_SampleStop)(handle)
    }
    pub unsafe fn BASS_StreamCreate(
        &self,
        freq: DWORD,
        chans: DWORD,
        flags: DWORD,
        proc_: STREAMPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM {
        (self.BASS_StreamCreate)(freq, chans, flags, proc_, user)
    }
    pub unsafe fn BASS_StreamCreateFile(
        &self,
        mem: BOOL,
        file: *const ::std::os::raw::c_void,
        offset: QWORD,
        length: QWORD,
        flags: DWORD,
    ) -> HSTREAM {
        (self.BASS_StreamCreateFile)(mem, file, offset, length, flags)
    }
    pub unsafe fn BASS_StreamCreateURL(
        &self,
        url: *const ::std::os::raw::c_char,
        offset: DWORD,
        flags: DWORD,
        proc_: DOWNLOADPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM {
        (self.BASS_StreamCreateURL)(url, offset, flags, proc_, user)
    }
    pub unsafe fn BASS_StreamCreateFileUser(
        &self,
        system: DWORD,
        flags: DWORD,
        proc_: *const BASS_FILEPROCS,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM {
        (self.BASS_StreamCreateFileUser)(system, flags, proc_, user)
    }
    pub unsafe fn BASS_StreamFree(&self, handle: HSTREAM) -> BOOL {
        (self.BASS_StreamFree)(handle)
    }
    pub unsafe fn BASS_StreamGetFilePosition(&self, handle: HSTREAM, mode: DWORD) -> QWORD {
        (self.BASS_StreamGetFilePosition)(handle, mode)
    }
    pub unsafe fn BASS_StreamPutData(
        &self,
        handle: HSTREAM,
        buffer: *const ::std::os::raw::c_void,
        length: DWORD,
    ) -> DWORD {
        (self.BASS_StreamPutData)(handle, buffer, length)
    }
    pub unsafe fn BASS_StreamPutFileData(
        &self,
        handle: HSTREAM,
        buffer: *const ::std::os::raw::c_void,
        length: DWORD,
    ) -> DWORD {
        (self.BASS_StreamPutFileData)(handle, buffer, length)
    }
    pub unsafe fn BASS_MusicLoad(
        &self,
        mem: BOOL,
        file: *const ::std::os::raw::c_void,
        offset: QWORD,
        length: DWORD,
        flags: DWORD,
        freq: DWORD,
    ) -> HMUSIC {
        (self.BASS_MusicLoad)(mem, file, offset, length, flags, freq)
    }
    pub unsafe fn BASS_MusicFree(&self, handle: HMUSIC) -> BOOL {
        (self.BASS_MusicFree)(handle)
    }
    pub unsafe fn BASS_RecordGetDeviceInfo(
        &self,
        device: DWORD,
        info: *mut BASS_DEVICEINFO,
    ) -> BOOL {
        (self.BASS_RecordGetDeviceInfo)(device, info)
    }
    pub unsafe fn BASS_RecordInit(&self, device: ::std::os::raw::c_int) -> BOOL {
        (self.BASS_RecordInit)(device)
    }
    pub unsafe fn BASS_RecordFree(&self) -> BOOL {
        (self.BASS_RecordFree)()
    }
    pub unsafe fn BASS_RecordSetDevice(&self, device: DWORD) -> BOOL {
        (self.BASS_RecordSetDevice)(device)
    }
    pub unsafe fn BASS_RecordGetDevice(&self) -> DWORD {
        (self.BASS_RecordGetDevice)()
    }
    pub unsafe fn BASS_RecordGetInfo(&self, info: *mut BASS_RECORDINFO) -> BOOL {
        (self.BASS_RecordGetInfo)(info)
    }
    pub unsafe fn BASS_RecordGetInputName(
        &self,
        input: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self.BASS_RecordGetInputName)(input)
    }
    pub unsafe fn BASS_RecordSetInput(
        &self,
        input: ::std::os::raw::c_int,
        flags: DWORD,
        volume: f32,
    ) -> BOOL {
        (self.BASS_RecordSetInput)(input, flags, volume)
    }
    pub unsafe fn BASS_RecordGetInput(
        &self,
        input: ::std::os::raw::c_int,
        volume: *mut f32,
    ) -> DWORD {
        (self.BASS_RecordGetInput)(input, volume)
    }
    pub unsafe fn BASS_RecordStart(
        &self,
        freq: DWORD,
        chans: DWORD,
        flags: DWORD,
        proc_: RECORDPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HRECORD {
        (self.BASS_RecordStart)(freq, chans, flags, proc_, user)
    }
    pub unsafe fn BASS_ChannelBytes2Seconds(&self, handle: DWORD, pos: QWORD) -> f64 {
        (self.BASS_ChannelBytes2Seconds)(handle, pos)
    }
    pub unsafe fn BASS_ChannelSeconds2Bytes(&self, handle: DWORD, pos: f64) -> QWORD {
        (self.BASS_ChannelSeconds2Bytes)(handle, pos)
    }
    pub unsafe fn BASS_ChannelGetDevice(&self, handle: DWORD) -> DWORD {
        (self.BASS_ChannelGetDevice)(handle)
    }
    pub unsafe fn BASS_ChannelSetDevice(&self, handle: DWORD, device: DWORD) -> BOOL {
        (self.BASS_ChannelSetDevice)(handle, device)
    }
    pub unsafe fn BASS_ChannelIsActive(&self, handle: DWORD) -> DWORD {
        (self.BASS_ChannelIsActive)(handle)
    }
    pub unsafe fn BASS_ChannelGetInfo(&self, handle: DWORD, info: *mut BASS_CHANNELINFO) -> BOOL {
        (self.BASS_ChannelGetInfo)(handle, info)
    }
    pub unsafe fn BASS_ChannelGetTags(
        &self,
        handle: DWORD,
        tags: DWORD,
    ) -> *const ::std::os::raw::c_char {
        (self.BASS_ChannelGetTags)(handle, tags)
    }
    pub unsafe fn BASS_ChannelFlags(&self, handle: DWORD, flags: DWORD, mask: DWORD) -> DWORD {
        (self.BASS_ChannelFlags)(handle, flags, mask)
    }
    pub unsafe fn BASS_ChannelLock(&self, handle: DWORD, lock: BOOL) -> BOOL {
        (self.BASS_ChannelLock)(handle, lock)
    }
    pub unsafe fn BASS_ChannelFree(&self, handle: DWORD) -> BOOL {
        (self.BASS_ChannelFree)(handle)
    }
    pub unsafe fn BASS_ChannelPlay(&self, handle: DWORD, restart: BOOL) -> BOOL {
        (self.BASS_ChannelPlay)(handle, restart)
    }
    pub unsafe fn BASS_ChannelStart(&self, handle: DWORD) -> BOOL {
        (self.BASS_ChannelStart)(handle)
    }
    pub unsafe fn BASS_ChannelStop(&self, handle: DWORD) -> BOOL {
        (self.BASS_ChannelStop)(handle)
    }
    pub unsafe fn BASS_ChannelPause(&self, handle: DWORD) -> BOOL {
        (self.BASS_ChannelPause)(handle)
    }
    pub unsafe fn BASS_ChannelUpdate(&self, handle: DWORD, length: DWORD) -> BOOL {
        (self.BASS_ChannelUpdate)(handle, length)
    }
    pub unsafe fn BASS_ChannelSetAttribute(
        &self,
        handle: DWORD,
        attrib: DWORD,
        value: f32,
    ) -> BOOL {
        (self.BASS_ChannelSetAttribute)(handle, attrib, value)
    }
    pub unsafe fn BASS_ChannelGetAttribute(
        &self,
        handle: DWORD,
        attrib: DWORD,
        value: *mut f32,
    ) -> BOOL {
        (self.BASS_ChannelGetAttribute)(handle, attrib, value)
    }
    pub unsafe fn BASS_ChannelSlideAttribute(
        &self,
        handle: DWORD,
        attrib: DWORD,
        value: f32,
        time: DWORD,
    ) -> BOOL {
        (self.BASS_ChannelSlideAttribute)(handle, attrib, value, time)
    }
    pub unsafe fn BASS_ChannelIsSliding(&self, handle: DWORD, attrib: DWORD) -> BOOL {
        (self.BASS_ChannelIsSliding)(handle, attrib)
    }
    pub unsafe fn BASS_ChannelSetAttributeEx(
        &self,
        handle: DWORD,
        attrib: DWORD,
        value: *mut ::std::os::raw::c_void,
        size: DWORD,
    ) -> BOOL {
        (self.BASS_ChannelSetAttributeEx)(handle, attrib, value, size)
    }
    pub unsafe fn BASS_ChannelGetAttributeEx(
        &self,
        handle: DWORD,
        attrib: DWORD,
        value: *mut ::std::os::raw::c_void,
        size: DWORD,
    ) -> DWORD {
        (self.BASS_ChannelGetAttributeEx)(handle, attrib, value, size)
    }
    pub unsafe fn BASS_ChannelSet3DAttributes(
        &self,
        handle: DWORD,
        mode: ::std::os::raw::c_int,
        min: f32,
        max: f32,
        iangle: ::std::os::raw::c_int,
        oangle: ::std::os::raw::c_int,
        outvol: f32,
    ) -> BOOL {
        (self.BASS_ChannelSet3DAttributes)(handle, mode, min, max, iangle, oangle, outvol)
    }
    pub unsafe fn BASS_ChannelGet3DAttributes(
        &self,
        handle: DWORD,
        mode: *mut DWORD,
        min: *mut f32,
        max: *mut f32,
        iangle: *mut DWORD,
        oangle: *mut DWORD,
        outvol: *mut f32,
    ) -> BOOL {
        (self.BASS_ChannelGet3DAttributes)(handle, mode, min, max, iangle, oangle, outvol)
    }
    pub unsafe fn BASS_ChannelSet3DPosition(
        &self,
        handle: DWORD,
        pos: *const BASS_3DVECTOR,
        orient: *const BASS_3DVECTOR,
        vel: *const BASS_3DVECTOR,
    ) -> BOOL {
        (self.BASS_ChannelSet3DPosition)(handle, pos, orient, vel)
    }
    pub unsafe fn BASS_ChannelGet3DPosition(
        &self,
        handle: DWORD,
        pos: *mut BASS_3DVECTOR,
        orient: *mut BASS_3DVECTOR,
        vel: *mut BASS_3DVECTOR,
    ) -> BOOL {
        (self.BASS_ChannelGet3DPosition)(handle, pos, orient, vel)
    }
    pub unsafe fn BASS_ChannelGetLength(&self, handle: DWORD, mode: DWORD) -> QWORD {
        (self.BASS_ChannelGetLength)(handle, mode)
    }
    pub unsafe fn BASS_ChannelSetPosition(&self, handle: DWORD, pos: QWORD, mode: DWORD) -> BOOL {
        (self.BASS_ChannelSetPosition)(handle, pos, mode)
    }
    pub unsafe fn BASS_ChannelGetPosition(&self, handle: DWORD, mode: DWORD) -> QWORD {
        (self.BASS_ChannelGetPosition)(handle, mode)
    }
    pub unsafe fn BASS_ChannelGetLevel(&self, handle: DWORD) -> DWORD {
        (self.BASS_ChannelGetLevel)(handle)
    }
    pub unsafe fn BASS_ChannelGetLevelEx(
        &self,
        handle: DWORD,
        levels: *mut f32,
        length: f32,
        flags: DWORD,
    ) -> BOOL {
        (self.BASS_ChannelGetLevelEx)(handle, levels, length, flags)
    }
    pub unsafe fn BASS_ChannelGetData(
        &self,
        handle: DWORD,
        buffer: *mut ::std::os::raw::c_void,
        length: DWORD,
    ) -> DWORD {
        (self.BASS_ChannelGetData)(handle, buffer, length)
    }
    pub unsafe fn BASS_ChannelSetSync(
        &self,
        handle: DWORD,
        type_: DWORD,
        param: QWORD,
        proc_: SYNCPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSYNC {
        (self.BASS_ChannelSetSync)(handle, type_, param, proc_, user)
    }
    pub unsafe fn BASS_ChannelRemoveSync(&self, handle: DWORD, sync: HSYNC) -> BOOL {
        (self.BASS_ChannelRemoveSync)(handle, sync)
    }
    pub unsafe fn BASS_ChannelSetLink(&self, handle: DWORD, chan: DWORD) -> BOOL {
        (self.BASS_ChannelSetLink)(handle, chan)
    }
    pub unsafe fn BASS_ChannelRemoveLink(&self, handle: DWORD, chan: DWORD) -> BOOL {
        (self.BASS_ChannelRemoveLink)(handle, chan)
    }
    pub unsafe fn BASS_ChannelSetDSP(
        &self,
        handle: DWORD,
        proc_: DSPPROC,
        user: *mut ::std::os::raw::c_void,
        priority: ::std::os::raw::c_int,
    ) -> HDSP {
        (self.BASS_ChannelSetDSP)(handle, proc_, user, priority)
    }
    pub unsafe fn BASS_ChannelRemoveDSP(&self, handle: DWORD, dsp: HDSP) -> BOOL {
        (self.BASS_ChannelRemoveDSP)(handle, dsp)
    }
    pub unsafe fn BASS_ChannelSetFX(
        &self,
        handle: DWORD,
        type_: DWORD,
        priority: ::std::os::raw::c_int,
    ) -> HFX {
        (self.BASS_ChannelSetFX)(handle, type_, priority)
    }
    pub unsafe fn BASS_ChannelRemoveFX(&self, handle: DWORD, fx: HFX) -> BOOL {
        (self.BASS_ChannelRemoveFX)(handle, fx)
    }
    pub unsafe fn BASS_FXSetParameters(
        &self,
        handle: HFX,
        params: *const ::std::os::raw::c_void,
    ) -> BOOL {
        (self.BASS_FXSetParameters)(handle, params)
    }
    pub unsafe fn BASS_FXGetParameters(
        &self,
        handle: HFX,
        params: *mut ::std::os::raw::c_void,
    ) -> BOOL {
        (self.BASS_FXGetParameters)(handle, params)
    }
    pub unsafe fn BASS_FXSetPriority(&self, handle: HFX, priority: ::std::os::raw::c_int) -> BOOL {
        (self.BASS_FXSetPriority)(handle, priority)
    }
    pub unsafe fn BASS_FXReset(&self, handle: DWORD) -> BOOL {
        (self.BASS_FXReset)(handle)
    }
}
