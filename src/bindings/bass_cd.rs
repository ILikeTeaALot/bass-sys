/* automatically generated by rust-bindgen 0.69.4 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
use super::bass::*;

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const BASS_ERROR_NOCD: u32 = 12;
pub const BASS_ERROR_CDTRACK: u32 = 13;
pub const BASS_CONFIG_CD_FREEOLD: u32 = 66048;
pub const BASS_CONFIG_CD_RETRY: u32 = 66049;
pub const BASS_CONFIG_CD_AUTOSPEED: u32 = 66050;
pub const BASS_CONFIG_CD_SKIPERROR: u32 = 66051;
pub const BASS_CONFIG_CD_READ: u32 = 66053;
pub const BASS_CONFIG_CD_TIMEOUT: u32 = 66054;
pub const BASS_CONFIG_CD_CDDB_SERVER: u32 = 66052;
pub const BASS_CD_IF_AUTO: u32 = 0;
pub const BASS_CD_IF_SPTI: u32 = 1;
pub const BASS_CD_IF_ASPI: u32 = 2;
pub const BASS_CD_IF_WIO: u32 = 3;
pub const BASS_CD_IF_LINUX: u32 = 4;
pub const BASS_CD_RWFLAG_READCDR: u32 = 1;
pub const BASS_CD_RWFLAG_READCDRW: u32 = 2;
pub const BASS_CD_RWFLAG_READCDRW2: u32 = 4;
pub const BASS_CD_RWFLAG_READDVD: u32 = 8;
pub const BASS_CD_RWFLAG_READDVDR: u32 = 16;
pub const BASS_CD_RWFLAG_READDVDRAM: u32 = 32;
pub const BASS_CD_RWFLAG_READANALOG: u32 = 65536;
pub const BASS_CD_RWFLAG_READM2F1: u32 = 1048576;
pub const BASS_CD_RWFLAG_READM2F2: u32 = 2097152;
pub const BASS_CD_RWFLAG_READMULTI: u32 = 4194304;
pub const BASS_CD_RWFLAG_READCDDA: u32 = 16777216;
pub const BASS_CD_RWFLAG_READCDDASIA: u32 = 33554432;
pub const BASS_CD_RWFLAG_READSUBCHAN: u32 = 67108864;
pub const BASS_CD_RWFLAG_READSUBCHANDI: u32 = 134217728;
pub const BASS_CD_RWFLAG_READC2: u32 = 268435456;
pub const BASS_CD_RWFLAG_READISRC: u32 = 536870912;
pub const BASS_CD_RWFLAG_READUPC: u32 = 1073741824;
pub const BASS_CD_SUBCHANNEL: u32 = 512;
pub const BASS_CD_SUBCHANNEL_NOHW: u32 = 1024;
pub const BASS_CD_C2ERRORS: u32 = 2048;
pub const BASS_SYNC_CD_ERROR: u32 = 1000;
pub const BASS_SYNC_CD_SPEED: u32 = 1002;
pub const BASS_CD_DOOR_CLOSE: u32 = 0;
pub const BASS_CD_DOOR_OPEN: u32 = 1;
pub const BASS_CD_DOOR_LOCK: u32 = 2;
pub const BASS_CD_DOOR_UNLOCK: u32 = 3;
pub const BASS_CDID_UPC: u32 = 1;
pub const BASS_CDID_CDDB: u32 = 2;
pub const BASS_CDID_CDDB2: u32 = 3;
pub const BASS_CDID_TEXT: u32 = 4;
pub const BASS_CDID_CDPLAYER: u32 = 5;
pub const BASS_CDID_MUSICBRAINZ: u32 = 6;
pub const BASS_CDID_ISRC: u32 = 256;
pub const BASS_CDID_CDDB_QUERY: u32 = 512;
pub const BASS_CDID_CDDB_READ: u32 = 513;
pub const BASS_CDID_CDDB_READ_CACHE: u32 = 767;
pub const BASS_CD_TOC_TIME: u32 = 256;
pub const BASS_CD_TOC_INDEX: u32 = 512;
pub const BASS_CD_TOC_CON_PRE: u32 = 1;
pub const BASS_CD_TOC_CON_COPY: u32 = 2;
pub const BASS_CD_TOC_CON_DATA: u32 = 4;
pub const BASS_CD_DATA_SUBCHANNEL: u32 = 0;
pub const BASS_CD_DATA_C2: u32 = 1;
pub const BASS_CD_TRACK_PREGAP: u32 = 65535;
pub const BASS_CTYPE_STREAM_CD: u32 = 66048;
pub const BASS_POS_CD_TRACK: u32 = 4;
#[repr(C)]
pub struct BASS_CD_INFO {
    #[doc = " manufacturer"]
    pub vendor: *const ::std::os::raw::c_char,
    #[doc = " model"]
    pub product: *const ::std::os::raw::c_char,
    #[doc = " revision"]
    pub rev: *const ::std::os::raw::c_char,
    #[doc = " drive letter"]
    pub letter: ::std::os::raw::c_int,
    #[doc = " read/write capability flags"]
    pub rwflags: DWORD,
    #[doc = " BASS_CD_DOOR_OPEN/CLOSE is supported?"]
    pub canopen: BOOL,
    #[doc = " BASS_CD_DOOR_LOCK/UNLOCK is supported?"]
    pub canlock: BOOL,
    #[doc = " max read speed (KB/s)"]
    pub maxspeed: DWORD,
    #[doc = " cache size (KB)"]
    pub cache: DWORD,
    #[doc = " can read CD-TEXT"]
    pub cdtext: BOOL,
}
#[test]
fn bindgen_test_layout_BASS_CD_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_CD_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_CD_INFO>(),
        56usize,
        concat!("Size of: ", stringify!(BASS_CD_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_CD_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_CD_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).product) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(product)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(rev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).letter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(letter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwflags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(rwflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canopen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(canopen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canlock) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(canlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxspeed) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(maxspeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdtext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_INFO),
            "::",
            stringify!(cdtext)
        )
    );
}
impl Default for BASS_CD_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for BASS_CD_INFO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "BASS_CD_INFO {{ vendor: {:?}, product: {:?}, rev: {:?}, letter: {:?} }}",
            self.vendor, self.product, self.rev, self.letter
        )
    }
}
#[doc = " TOC structures"]
#[repr(C)]
pub struct BASS_CD_TOC_TRACK {
    pub res1: BYTE,
    #[doc = " ADR + control"]
    pub adrcon: BYTE,
    #[doc = " track number"]
    pub track: BYTE,
    pub res2: BYTE,
    pub __bindgen_anon_1: BASS_CD_TOC_TRACK__bindgen_ty_1,
}
#[repr(C)]
pub struct BASS_CD_TOC_TRACK__bindgen_ty_1 {
    #[doc = " start address (logical block address)"]
    pub lba: __BindgenUnionField<DWORD>,
    #[doc = " start address (hours/minutes/seconds/frames)"]
    pub hmsf: __BindgenUnionField<[BYTE; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_BASS_CD_TOC_TRACK__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_CD_TOC_TRACK__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_CD_TOC_TRACK__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(BASS_CD_TOC_TRACK__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_CD_TOC_TRACK__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_CD_TOC_TRACK__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lba) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC_TRACK__bindgen_ty_1),
            "::",
            stringify!(lba)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hmsf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC_TRACK__bindgen_ty_1),
            "::",
            stringify!(hmsf)
        )
    );
}
impl Default for BASS_CD_TOC_TRACK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for BASS_CD_TOC_TRACK__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "BASS_CD_TOC_TRACK__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_BASS_CD_TOC_TRACK() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_CD_TOC_TRACK> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_CD_TOC_TRACK>(),
        8usize,
        concat!("Size of: ", stringify!(BASS_CD_TOC_TRACK))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_CD_TOC_TRACK>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_CD_TOC_TRACK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC_TRACK),
            "::",
            stringify!(res1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adrcon) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC_TRACK),
            "::",
            stringify!(adrcon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).track) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC_TRACK),
            "::",
            stringify!(track)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res2) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC_TRACK),
            "::",
            stringify!(res2)
        )
    );
}
impl Default for BASS_CD_TOC_TRACK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for BASS_CD_TOC_TRACK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "BASS_CD_TOC_TRACK {{ __bindgen_anon_1: {:?} }}",
            self.__bindgen_anon_1
        )
    }
}
#[repr(C)]
pub struct BASS_CD_TOC {
    #[doc = " size of TOC"]
    pub size: WORD,
    #[doc = " first track"]
    pub first: BYTE,
    #[doc = " last track"]
    pub last: BYTE,
    #[doc = " up to 100 tracks"]
    pub tracks: [BASS_CD_TOC_TRACK; 100usize],
}
#[test]
fn bindgen_test_layout_BASS_CD_TOC() {
    const UNINIT: ::std::mem::MaybeUninit<BASS_CD_TOC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASS_CD_TOC>(),
        804usize,
        concat!("Size of: ", stringify!(BASS_CD_TOC))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_CD_TOC>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_CD_TOC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracks) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_CD_TOC),
            "::",
            stringify!(tracks)
        )
    );
}
impl Default for BASS_CD_TOC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for BASS_CD_TOC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "BASS_CD_TOC {{ tracks: {:?} }}", self.tracks)
    }
}
pub type CDDATAPROC = ::std::option::Option<
    unsafe extern "C" fn(
        handle: HSTREAM,
        pos: ::std::os::raw::c_int,
        type_: DWORD,
        buffer: *const ::std::os::raw::c_void,
        length: DWORD,
        user: *mut ::std::os::raw::c_void,
    ),
>;
extern crate libloading;
pub struct BASS_CD {
    __library: ::libloading::Library,
    pub BASS_CD_SetInterface: unsafe extern "C" fn(iface: DWORD) -> DWORD,
    pub BASS_CD_GetInfo: unsafe extern "C" fn(drive: DWORD, info: *mut BASS_CD_INFO) -> BOOL,
    pub BASS_CD_Door: unsafe extern "C" fn(drive: DWORD, action: DWORD) -> BOOL,
    pub BASS_CD_DoorIsOpen: unsafe extern "C" fn(drive: DWORD) -> BOOL,
    pub BASS_CD_DoorIsLocked: unsafe extern "C" fn(drive: DWORD) -> BOOL,
    pub BASS_CD_IsReady: unsafe extern "C" fn(drive: DWORD) -> BOOL,
    pub BASS_CD_GetTracks: unsafe extern "C" fn(drive: DWORD) -> DWORD,
    pub BASS_CD_GetTrackLength: unsafe extern "C" fn(drive: DWORD, track: DWORD) -> DWORD,
    pub BASS_CD_GetTrackPregap: unsafe extern "C" fn(drive: DWORD, track: DWORD) -> DWORD,
    pub BASS_CD_GetTOC:
        unsafe extern "C" fn(drive: DWORD, mode: DWORD, toc: *mut BASS_CD_TOC) -> BOOL,
    pub BASS_CD_GetID:
        unsafe extern "C" fn(drive: DWORD, id: DWORD) -> *const ::std::os::raw::c_char,
    pub BASS_CD_GetSpeed: unsafe extern "C" fn(drive: DWORD) -> DWORD,
    pub BASS_CD_SetSpeed: unsafe extern "C" fn(drive: DWORD, speed: DWORD) -> BOOL,
    pub BASS_CD_GetCache: unsafe extern "C" fn(drive: DWORD) -> DWORD,
    pub BASS_CD_SetCache: unsafe extern "C" fn(drive: DWORD, enable: BOOL) -> BOOL,
    pub BASS_CD_SetOffset:
        unsafe extern "C" fn(drive: DWORD, offset: ::std::os::raw::c_int) -> BOOL,
    pub BASS_CD_Release: unsafe extern "C" fn(drive: DWORD) -> BOOL,
    pub BASS_CD_StreamCreate:
        unsafe extern "C" fn(drive: DWORD, track: DWORD, flags: DWORD) -> HSTREAM,
    pub BASS_CD_StreamCreateFile:
        unsafe extern "C" fn(file: *const ::std::os::raw::c_char, flags: DWORD) -> HSTREAM,
    pub BASS_CD_StreamCreateEx: unsafe extern "C" fn(
        drive: DWORD,
        track: DWORD,
        flags: DWORD,
        proc_: CDDATAPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM,
    pub BASS_CD_StreamCreateFileEx: unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        flags: DWORD,
        proc_: CDDATAPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM,
    pub BASS_CD_StreamGetTrack: unsafe extern "C" fn(handle: HSTREAM) -> DWORD,
    pub BASS_CD_StreamSetTrack: unsafe extern "C" fn(handle: HSTREAM, track: DWORD) -> BOOL,
    pub BASS_CD_Analog_Play: unsafe extern "C" fn(drive: DWORD, track: DWORD, pos: DWORD) -> BOOL,
    pub BASS_CD_Analog_PlayFile:
        unsafe extern "C" fn(file: *const ::std::os::raw::c_char, pos: DWORD) -> DWORD,
    pub BASS_CD_Analog_Stop: unsafe extern "C" fn(drive: DWORD) -> BOOL,
    pub BASS_CD_Analog_IsActive: unsafe extern "C" fn(drive: DWORD) -> DWORD,
    pub BASS_CD_Analog_GetPosition: unsafe extern "C" fn(drive: DWORD) -> DWORD,
}
impl BASS_CD {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let BASS_CD_SetInterface = __library.get(b"BASS_CD_SetInterface\0").map(|sym| *sym)?;
        let BASS_CD_GetInfo = __library.get(b"BASS_CD_GetInfo\0").map(|sym| *sym)?;
        let BASS_CD_Door = __library.get(b"BASS_CD_Door\0").map(|sym| *sym)?;
        let BASS_CD_DoorIsOpen = __library.get(b"BASS_CD_DoorIsOpen\0").map(|sym| *sym)?;
        let BASS_CD_DoorIsLocked = __library.get(b"BASS_CD_DoorIsLocked\0").map(|sym| *sym)?;
        let BASS_CD_IsReady = __library.get(b"BASS_CD_IsReady\0").map(|sym| *sym)?;
        let BASS_CD_GetTracks = __library.get(b"BASS_CD_GetTracks\0").map(|sym| *sym)?;
        let BASS_CD_GetTrackLength = __library.get(b"BASS_CD_GetTrackLength\0").map(|sym| *sym)?;
        let BASS_CD_GetTrackPregap = __library.get(b"BASS_CD_GetTrackPregap\0").map(|sym| *sym)?;
        let BASS_CD_GetTOC = __library.get(b"BASS_CD_GetTOC\0").map(|sym| *sym)?;
        let BASS_CD_GetID = __library.get(b"BASS_CD_GetID\0").map(|sym| *sym)?;
        let BASS_CD_GetSpeed = __library.get(b"BASS_CD_GetSpeed\0").map(|sym| *sym)?;
        let BASS_CD_SetSpeed = __library.get(b"BASS_CD_SetSpeed\0").map(|sym| *sym)?;
        let BASS_CD_GetCache = __library.get(b"BASS_CD_GetCache\0").map(|sym| *sym)?;
        let BASS_CD_SetCache = __library.get(b"BASS_CD_SetCache\0").map(|sym| *sym)?;
        let BASS_CD_SetOffset = __library.get(b"BASS_CD_SetOffset\0").map(|sym| *sym)?;
        let BASS_CD_Release = __library.get(b"BASS_CD_Release\0").map(|sym| *sym)?;
        let BASS_CD_StreamCreate = __library.get(b"BASS_CD_StreamCreate\0").map(|sym| *sym)?;
        let BASS_CD_StreamCreateFile = __library
            .get(b"BASS_CD_StreamCreateFile\0")
            .map(|sym| *sym)?;
        let BASS_CD_StreamCreateEx = __library.get(b"BASS_CD_StreamCreateEx\0").map(|sym| *sym)?;
        let BASS_CD_StreamCreateFileEx = __library
            .get(b"BASS_CD_StreamCreateFileEx\0")
            .map(|sym| *sym)?;
        let BASS_CD_StreamGetTrack = __library.get(b"BASS_CD_StreamGetTrack\0").map(|sym| *sym)?;
        let BASS_CD_StreamSetTrack = __library.get(b"BASS_CD_StreamSetTrack\0").map(|sym| *sym)?;
        let BASS_CD_Analog_Play = __library.get(b"BASS_CD_Analog_Play\0").map(|sym| *sym)?;
        let BASS_CD_Analog_PlayFile = __library
            .get(b"BASS_CD_Analog_PlayFile\0")
            .map(|sym| *sym)?;
        let BASS_CD_Analog_Stop = __library.get(b"BASS_CD_Analog_Stop\0").map(|sym| *sym)?;
        let BASS_CD_Analog_IsActive = __library
            .get(b"BASS_CD_Analog_IsActive\0")
            .map(|sym| *sym)?;
        let BASS_CD_Analog_GetPosition = __library
            .get(b"BASS_CD_Analog_GetPosition\0")
            .map(|sym| *sym)?;
        Ok(BASS_CD {
            __library,
            BASS_CD_SetInterface,
            BASS_CD_GetInfo,
            BASS_CD_Door,
            BASS_CD_DoorIsOpen,
            BASS_CD_DoorIsLocked,
            BASS_CD_IsReady,
            BASS_CD_GetTracks,
            BASS_CD_GetTrackLength,
            BASS_CD_GetTrackPregap,
            BASS_CD_GetTOC,
            BASS_CD_GetID,
            BASS_CD_GetSpeed,
            BASS_CD_SetSpeed,
            BASS_CD_GetCache,
            BASS_CD_SetCache,
            BASS_CD_SetOffset,
            BASS_CD_Release,
            BASS_CD_StreamCreate,
            BASS_CD_StreamCreateFile,
            BASS_CD_StreamCreateEx,
            BASS_CD_StreamCreateFileEx,
            BASS_CD_StreamGetTrack,
            BASS_CD_StreamSetTrack,
            BASS_CD_Analog_Play,
            BASS_CD_Analog_PlayFile,
            BASS_CD_Analog_Stop,
            BASS_CD_Analog_IsActive,
            BASS_CD_Analog_GetPosition,
        })
    }
    pub unsafe fn BASS_CD_SetInterface(&self, iface: DWORD) -> DWORD {
        (self.BASS_CD_SetInterface)(iface)
    }
    pub unsafe fn BASS_CD_GetInfo(&self, drive: DWORD, info: *mut BASS_CD_INFO) -> BOOL {
        (self.BASS_CD_GetInfo)(drive, info)
    }
    pub unsafe fn BASS_CD_Door(&self, drive: DWORD, action: DWORD) -> BOOL {
        (self.BASS_CD_Door)(drive, action)
    }
    pub unsafe fn BASS_CD_DoorIsOpen(&self, drive: DWORD) -> BOOL {
        (self.BASS_CD_DoorIsOpen)(drive)
    }
    pub unsafe fn BASS_CD_DoorIsLocked(&self, drive: DWORD) -> BOOL {
        (self.BASS_CD_DoorIsLocked)(drive)
    }
    pub unsafe fn BASS_CD_IsReady(&self, drive: DWORD) -> BOOL {
        (self.BASS_CD_IsReady)(drive)
    }
    pub unsafe fn BASS_CD_GetTracks(&self, drive: DWORD) -> DWORD {
        (self.BASS_CD_GetTracks)(drive)
    }
    pub unsafe fn BASS_CD_GetTrackLength(&self, drive: DWORD, track: DWORD) -> DWORD {
        (self.BASS_CD_GetTrackLength)(drive, track)
    }
    pub unsafe fn BASS_CD_GetTrackPregap(&self, drive: DWORD, track: DWORD) -> DWORD {
        (self.BASS_CD_GetTrackPregap)(drive, track)
    }
    pub unsafe fn BASS_CD_GetTOC(&self, drive: DWORD, mode: DWORD, toc: *mut BASS_CD_TOC) -> BOOL {
        (self.BASS_CD_GetTOC)(drive, mode, toc)
    }
    pub unsafe fn BASS_CD_GetID(&self, drive: DWORD, id: DWORD) -> *const ::std::os::raw::c_char {
        (self.BASS_CD_GetID)(drive, id)
    }
    pub unsafe fn BASS_CD_GetSpeed(&self, drive: DWORD) -> DWORD {
        (self.BASS_CD_GetSpeed)(drive)
    }
    pub unsafe fn BASS_CD_SetSpeed(&self, drive: DWORD, speed: DWORD) -> BOOL {
        (self.BASS_CD_SetSpeed)(drive, speed)
    }
    pub unsafe fn BASS_CD_GetCache(&self, drive: DWORD) -> DWORD {
        (self.BASS_CD_GetCache)(drive)
    }
    pub unsafe fn BASS_CD_SetCache(&self, drive: DWORD, enable: BOOL) -> BOOL {
        (self.BASS_CD_SetCache)(drive, enable)
    }
    pub unsafe fn BASS_CD_SetOffset(&self, drive: DWORD, offset: ::std::os::raw::c_int) -> BOOL {
        (self.BASS_CD_SetOffset)(drive, offset)
    }
    pub unsafe fn BASS_CD_Release(&self, drive: DWORD) -> BOOL {
        (self.BASS_CD_Release)(drive)
    }
    pub unsafe fn BASS_CD_StreamCreate(&self, drive: DWORD, track: DWORD, flags: DWORD) -> HSTREAM {
        (self.BASS_CD_StreamCreate)(drive, track, flags)
    }
    pub unsafe fn BASS_CD_StreamCreateFile(
        &self,
        file: *const ::std::os::raw::c_char,
        flags: DWORD,
    ) -> HSTREAM {
        (self.BASS_CD_StreamCreateFile)(file, flags)
    }
    pub unsafe fn BASS_CD_StreamCreateEx(
        &self,
        drive: DWORD,
        track: DWORD,
        flags: DWORD,
        proc_: CDDATAPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM {
        (self.BASS_CD_StreamCreateEx)(drive, track, flags, proc_, user)
    }
    pub unsafe fn BASS_CD_StreamCreateFileEx(
        &self,
        file: *const ::std::os::raw::c_char,
        flags: DWORD,
        proc_: CDDATAPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM {
        (self.BASS_CD_StreamCreateFileEx)(file, flags, proc_, user)
    }
    pub unsafe fn BASS_CD_StreamGetTrack(&self, handle: HSTREAM) -> DWORD {
        (self.BASS_CD_StreamGetTrack)(handle)
    }
    pub unsafe fn BASS_CD_StreamSetTrack(&self, handle: HSTREAM, track: DWORD) -> BOOL {
        (self.BASS_CD_StreamSetTrack)(handle, track)
    }
    pub unsafe fn BASS_CD_Analog_Play(&self, drive: DWORD, track: DWORD, pos: DWORD) -> BOOL {
        (self.BASS_CD_Analog_Play)(drive, track, pos)
    }
    pub unsafe fn BASS_CD_Analog_PlayFile(
        &self,
        file: *const ::std::os::raw::c_char,
        pos: DWORD,
    ) -> DWORD {
        (self.BASS_CD_Analog_PlayFile)(file, pos)
    }
    pub unsafe fn BASS_CD_Analog_Stop(&self, drive: DWORD) -> BOOL {
        (self.BASS_CD_Analog_Stop)(drive)
    }
    pub unsafe fn BASS_CD_Analog_IsActive(&self, drive: DWORD) -> DWORD {
        (self.BASS_CD_Analog_IsActive)(drive)
    }
    pub unsafe fn BASS_CD_Analog_GetPosition(&self, drive: DWORD) -> DWORD {
        (self.BASS_CD_Analog_GetPosition)(drive)
    }
}
